import { z } from "zod";

import {
  createTaskFile,
  type TaskCreateInput,
  type TaskCreateOutput,
} from "./workflows/taskFile.js";
import { registerAgent, whoami } from "./workflows/agentRegistry.js";
import { listTasks, updateTask } from "./workflows/taskState.js";
import { getStopState, setStopState } from "./workflows/stopFlag.js";
import {
  companionLocalPause,
  companionLocalResume,
  companionLocalStatus,
  companionLocalStop,
} from "./workflows/companionControl.js";
import { syncWithBaseBranch } from "./workflows/git.js";
import {
  appendProjectKnowledge,
  appendTeamChat,
  updateTeamStatus,
} from "./workflows/teamFiles.js";
import {
  createWorktree,
  listWorktrees,
  removeWorktree,
  type WorktreeCreateInput,
  type WorktreeCreateOutput,
} from "./workflows/worktree.js";
import { scanSystemMcps, authorizeMcpsForSwarm, getPolicy } from "./workflows/mcpScanner.js";
import { fileReserve, fileRelease, listFileLocks } from "./workflows/fileLocks.js";
import { announceTaskForBidding, bidForTask, pollSwarmEvents } from "./workflows/auction.js";
import { createGithubPr, checkMainHealth } from "./workflows/githubPr.js";
import { signalDependencyChange, syncDependencies } from "./workflows/dependencySync.js";
import { requestCrossAgentReview, respondToReview, listPendingReviews } from "./workflows/codeReview.js";
import { shareScreenshot, listScreenshots } from "./workflows/screenshot.js";
import { decomposeTask, getDecomposition } from "./workflows/decompose.js";
import { startVoting, castVote, getVotingSession, listOpenVotings } from "./workflows/voting.js";
import { autoDeleteMergedBranch, cleanupAllMergedBranches } from "./workflows/remoteCleanup.js";
import { logSwarmThought, getRecentThoughts } from "./workflows/swarmThoughts.js";
import { patrolMode } from "./workflows/ghostMode.js";
import { reportCiAlert, resolveAlert, getImmuneStatus, runLocalTests } from "./workflows/immuneSystem.js";
import { forecastFileTouches, getActiveForecasts, checkFileConflicts } from "./workflows/conflictForecast.js";
import { requestPlatformCheck, respondToPlatformCheck, getPendingPlatformChecks } from "./workflows/crossPlatform.js";
// v0.4 orchestrator features
import { saveBriefing, loadBriefing } from "./workflows/briefings.js";
import { updateSwarmPulse, getSwarmPulse } from "./workflows/pulse.js";
import { archiveFinding, searchKnowledge } from "./workflows/knowledgeBase.js";
import { triggerUrgentPreemption, resolveUrgent, getActiveUrgent } from "./workflows/preemption.js";
import { createSnapshot, triggerRollback, listSnapshots } from "./workflows/snapshot.js";
import { requestCollectiveAdvice, provideAdvice, getOpenAdviceRequests } from "./workflows/collectiveAdvice.js";
import { autoGenerateDocs, listDocs } from "./workflows/autoDoc.js";
import { trackExpertise, suggestAgentForTask, getAgentExpertise } from "./workflows/specialization.js";
import { predictConflicts, analyzeConflictHistory, getConflictHotspots, checkFileSafety, recordConflictEvent } from "./workflows/conflictPrediction.js";
import { generateTimeline, getTimelineVisualization } from "./workflows/timeline.js";
// v0.4 NEW advanced features
import { generateTaskDocumentation, listDocumentation, getDocumentation } from "./workflows/autoDocumentation.js";
import { recordAgentEdit, suggestAgentForTask as suggestAgentAdvanced, getTopExperts, listAllAgentExpertise } from "./workflows/agentSpecialization.js";
// v0.5 NEW features
import { checkAgentHealth, getDeadAgents, forceReassignTask, getSwarmHealthSummary } from "./workflows/agentHealth.js";
import { startSessionRecording, logSessionAction, stopSessionRecording, listSessionRecordings, replaySession } from "./workflows/sessionRecording.js";
import { runQualityGate, getQualityReport, setQualityThreshold, checkPrReady } from "./workflows/qualityGate.js";
import { logApiUsage, getAgentCosts, getProjectCosts, setBudgetLimit, checkBudgetRemaining } from "./workflows/costTracker.js";
import { estimateContextSize, compressBriefing, compressMultipleBriefings, getCompressionStats } from "./workflows/contextCompressor.js";
import { saveBaseline, checkRegression, listRegressions, resolveRegression, listBaselines } from "./workflows/regressionDetector.js";
// v0.6 Superpowers-inspired skills
import {
  startBrainstorm,
  askBrainstormQuestion,
  answerBrainstormQuestion,
  proposeApproaches,
  presentDesignSection,
  validateDesignSection,
  saveDesignDocument,
  getBrainstormSession,
  listBrainstormSessions,
} from "./workflows/brainstorming.js";
import {
  createImplementationPlan,
  addPlanTask,
  getNextTask,
  startTask,
  completeStep,
  completeTask,
  generateSubagentPrompt,
  exportPlanAsMarkdown,
  getPlanStatus,
  listPlans,
  markPlanReady,
} from "./workflows/writingPlans.js";
import {
  startDebugSession,
  logInvestigation,
  addEvidence,
  completePhase1,
  logPatterns,
  completePhase2,
  formHypothesis,
  testHypothesis,
  implementFix,
  verifyFix,
  getDebugSession,
  listDebugSessions,
  checkRedFlags,
} from "./workflows/systematicDebugging.js";

export const agentRegisterTool = [
  "agent_register",
  {
    title: "Register Agent",
    description:
      "Registers this machine as an agent and assigns a unique human-friendly name (generated by the MCP).",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        agent: z
          .object({
            agentId: z.string(),
            agentName: z.string(),
            hostname: z.string(),
            platform: z.string(),
            createdAtIso: z.string(),
            lastSeenIso: z.string().optional(),
          })
          .strict(),
      })
      .strict(),
  },
  async (input: { repoPath?: string; commitMode: "none" | "local" | "push" }) => {
    const output = await registerAgent({
      repoPath: input.repoPath,
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: output.repoRoot, agent: output.agent };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const taskLinkTool = [
  "task_link",
  {
    title: "Link Tasks",
    description:
      "Sets task.links for a taskId (dependencies/related tasks), rebuilds INDEX.md, and optionally commits/pushes.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        taskId: z.string().min(1),
        links: z.array(z.string()).default([]),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        taskId: z.string(),
        links: z.array(z.string()).optional(),
      })
      .strict(),
  },
  async (input: { repoPath?: string; taskId: string; links: string[]; commitMode: "none" | "local" | "push" }) => {
    const out = await updateTask({
      repoPath: input.repoPath,
      taskId: input.taskId,
      links: input.links,
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: out.repoRoot, taskId: out.task.taskId, links: out.task.links };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const syncWithBaseBranchTool = [
  "sync_with_base_branch",
  {
    title: "Sync With Base Branch",
    description:
      "Runs git fetch origin <baseBranch> and git rebase origin/<baseBranch> (Auto-Rebase).",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        baseBranch: z.string().optional().describe("Defaults to SWARM_BASE_BRANCH or 'main'."),
      })
      .strict(),
    outputSchema: z
      .object({
        baseBranch: z.string(),
        rebased: z.boolean(),
      })
      .strict(),
  },
  async (input: { repoPath?: string; baseBranch?: string }) => {
    const repoRoot = await (await import("./workflows/repo.js")).getRepoRoot(input.repoPath);
    const out = await syncWithBaseBranch({ repoRoot, baseBranch: input.baseBranch });
    return {
      content: [{ type: "text" as const, text: JSON.stringify(out) }],
      structuredContent: out,
    };
  },
] as const;

export const broadcastChatTool = [
  "broadcast_chat",
  {
    title: "Broadcast Chat",
    description:
      "Appends a message to swarm/TEAM_CHAT.md and/or swarm/PROJECT_KNOWLEDGE.md (commit+push by default).",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        message: z.string().min(1),
        channel: z.enum(["chat", "knowledge"]).default("chat"),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        ok: z.literal(true),
        channel: z.enum(["chat", "knowledge"]),
      })
      .strict(),
  },
  async (input: { repoPath?: string; message: string; channel: "chat" | "knowledge"; commitMode: "none" | "local" | "push" }) => {
    if (input.channel === "knowledge") {
      await appendProjectKnowledge({ repoPath: input.repoPath, message: input.message, commitMode: input.commitMode });
    } else {
      await appendTeamChat({ repoPath: input.repoPath, message: input.message, commitMode: input.commitMode });
    }
    const shaped = { ok: true as const, channel: input.channel };
    return { content: [{ type: "text" as const, text: JSON.stringify(shaped) }], structuredContent: shaped };
  },
] as const;

export const updateTeamDashboardTool = [
  "update_team_dashboard",
  {
    title: "Update Team Dashboard",
    description: "Writes swarm/TEAM_STATUS.md (commit+push by default).",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        statusLine: z.string().min(1),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({ ok: z.literal(true) })
      .strict(),
  },
  async (input: { repoPath?: string; statusLine: string; commitMode: "none" | "local" | "push" }) => {
    await updateTeamStatus({ repoPath: input.repoPath, statusLine: input.statusLine, commitMode: input.commitMode });
    const shaped = { ok: true as const };
    return { content: [{ type: "text" as const, text: JSON.stringify(shaped) }], structuredContent: shaped };
  },
] as const;

export const companionStatusLocalTool = [
  "companion_status_local",
  {
    title: "Companion Local Status",
    description:
      "Queries the always-online companion running on this machine via localhost control port.",
    inputSchema: z
      .object({
        port: z.number().int().positive().default(37373),
        token: z.string().optional(),
      })
      .strict(),
    outputSchema: z
      .object({
        ok: z.boolean(),
        stop: z.boolean().optional(),
        paused: z.boolean().optional(),
        agentName: z.string().optional(),
      })
      .strict(),
  },
  async (input: { port: number; token?: string }) => {
    const out = await companionLocalStatus(input.port, input.token);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(out) }],
      structuredContent: out,
    };
  },
] as const;

export const companionStopLocalTool = [
  "companion_stop_local",
  {
    title: "Companion Local Stop",
    description: "Stops the local companion immediately (does not depend on git).",
    inputSchema: z
      .object({
        port: z.number().int().positive().default(37373),
        token: z.string().optional(),
      })
      .strict(),
    outputSchema: z
      .object({
        ok: z.boolean(),
        stop: z.boolean().optional(),
      })
      .strict(),
  },
  async (input: { port: number; token?: string }) => {
    const out = await companionLocalStop(input.port, input.token);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(out) }],
      structuredContent: out,
    };
  },
] as const;

export const companionPauseLocalTool = [
  "companion_pause_local",
  {
    title: "Companion Local Pause",
    description: "Pauses local companion loop (keeps process alive).",
    inputSchema: z
      .object({
        port: z.number().int().positive().default(37373),
        token: z.string().optional(),
      })
      .strict(),
    outputSchema: z
      .object({
        ok: z.boolean(),
        paused: z.boolean().optional(),
      })
      .strict(),
  },
  async (input: { port: number; token?: string }) => {
    const out = await companionLocalPause(input.port, input.token);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(out) }],
      structuredContent: out,
    };
  },
] as const;

export const companionResumeLocalTool = [
  "companion_resume_local",
  {
    title: "Companion Local Resume",
    description: "Resumes local companion loop after pause.",
    inputSchema: z
      .object({
        port: z.number().int().positive().default(37373),
        token: z.string().optional(),
      })
      .strict(),
    outputSchema: z
      .object({
        ok: z.boolean(),
        paused: z.boolean().optional(),
      })
      .strict(),
  },
  async (input: { port: number; token?: string }) => {
    const out = await companionLocalResume(input.port, input.token);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(out) }],
      structuredContent: out,
    };
  },
] as const;

export const swarmStopStatusTool = [
  "swarm_stop_status",
  {
    title: "Swarm Stop Status",
    description: "Reads swarm/STOP.json (or defaults to running if absent).",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        state: z
          .object({
            stopped: z.boolean(),
            reason: z.string().optional(),
            by: z.string().optional(),
            tsIso: z.string(),
          })
          .strict(),
      })
      .strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const output = await getStopState(repoPath);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

export const swarmStopTool = [
  "swarm_stop",
  {
    title: "Stop Swarm",
    description:
      "Sets swarm/STOP.json stopped=true (commit+push by default) so all companions stop across machines.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        reason: z.string().optional(),
        by: z.string().optional(),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        state: z
          .object({
            stopped: z.literal(true),
            reason: z.string().optional(),
            by: z.string().optional(),
            tsIso: z.string(),
          })
          .strict(),
      })
      .strict(),
  },
  async (input: {
    repoPath?: string;
    reason?: string;
    by?: string;
    commitMode: "none" | "local" | "push";
  }) => {
    const out = await setStopState({
      repoPath: input.repoPath,
      stopped: true,
      reason: input.reason,
      by: input.by,
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: out.repoRoot, state: out.state };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const swarmResumeTool = [
  "swarm_resume",
  {
    title: "Resume Swarm",
    description:
      "Sets swarm/STOP.json stopped=false (commit+push by default) so companions can run again.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        by: z.string().optional(),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        state: z
          .object({
            stopped: z.literal(false),
            reason: z.string().optional(),
            by: z.string().optional(),
            tsIso: z.string(),
          })
          .strict(),
      })
      .strict(),
  },
  async (input: { repoPath?: string; by?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await setStopState({
      repoPath: input.repoPath,
      stopped: false,
      by: input.by,
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: out.repoRoot, state: out.state };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const agentWhoamiTool = [
  "agent_whoami",
  {
    title: "Agent WhoAmI",
    description:
      "Returns the agent identity for this machine if registered, otherwise null.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        agent: z
          .object({
            agentId: z.string(),
            agentName: z.string(),
            hostname: z.string(),
            platform: z.string(),
            createdAtIso: z.string(),
            lastSeenIso: z.string().optional(),
          })
          .nullable(),
      })
      .strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const output = await whoami(repoPath);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

export const taskCreateTool = [
  "task_create",
  {
    title: "Create Task File",
    description:
      "Creates a task markdown file under swarm/tasks/ in the current git repository.",
    inputSchema: z
      .object({
        repoPath: z
          .string()
          .optional()
          .describe(
            "Path inside the repo (any file/dir). If omitted, uses current working directory of the MCP process."
          ),
        shortDesc: z
          .string()
          .min(1)
          .describe("Short description slug (latin letters, numbers, dashes)."),
        title: z.string().min(1),
        questions: z.array(z.string()).default([]),
        answers: z.array(z.string()).default([]),
        notes: z.string().optional(),
        createdAtLocal: z
          .string()
          .optional()
          .describe(
            "Optional local timestamp like 2026-02-02 13:40. If omitted, server will generate." 
          ),
        commitMode: z
          .enum(["none", "local", "push"])
          .default("push")
          .describe(
            "Commit behavior: none=write files only, local=commit only, push=commit and push to origin. Default push."
          ),
      })
      .strict(),
    outputSchema: z
      .object({
        taskId: z.string(),
        filePath: z.string(),
        relativePath: z.string(),
        statePath: z.string(),
        stateRelativePath: z.string(),
        indexPath: z.string(),
        indexRelativePath: z.string(),
      })
      .strict(),
  },
  async (input: TaskCreateInput) => {
    const output: TaskCreateOutput = await createTaskFile(input);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

export const taskListTool = [
  "task_list",
  {
    title: "List Tasks",
    description:
      "Lists tasks from swarm/tasks/*.json and returns them sorted by taskId.",
    inputSchema: z
      .object({
        repoPath: z
          .string()
          .optional()
          .describe(
            "Path inside the repo (any file/dir). If omitted, uses current working directory of the MCP process."
          ),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        tasks: z.array(
          z
            .object({
              taskId: z.string(),
              title: z.string(),
              shortDesc: z.string(),
              createdAtIso: z.string(),
              createdAtLocal: z.string(),
              status: z.enum(["open", "in_progress", "needs_review", "done", "canceled"]),
              assignee: z.string().optional(),
              branch: z.string().optional(),
              links: z.array(z.string()).optional(),
            })
            .strict()
        ),
      })
      .strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const output = await listTasks(repoPath);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

export const taskSetStatusTool = [
  "task_set_status",
  {
    title: "Set Task Status",
    description:
      "Updates task status in swarm/tasks/<taskId>.json, rebuilds INDEX.md, and optionally commits/pushes.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        taskId: z.string().min(1),
        status: z.enum(["open", "in_progress", "needs_review", "done", "canceled"]),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        task: z
          .object({
            taskId: z.string(),
            title: z.string(),
            shortDesc: z.string(),
            createdAtIso: z.string(),
            createdAtLocal: z.string(),
            status: z.enum(["open", "in_progress", "needs_review", "done", "canceled"]),
            assignee: z.string().optional(),
            branch: z.string().optional(),
          })
          .strict(),
      })
      .strict(),
  },
  async (input: {
    repoPath?: string;
    taskId: string;
    status: "open" | "in_progress" | "needs_review" | "done" | "canceled";
    commitMode: "none" | "local" | "push";
  }) => {
    const output = await updateTask({
      repoPath: input.repoPath,
      taskId: input.taskId,
      status: input.status,
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: output.repoRoot, task: output.task };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const taskAssignTool = [
  "task_assign",
  {
    title: "Assign Task",
    description:
      "Assigns task to an agent by writing assignee into task JSON state and rebuilding INDEX.md.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        taskId: z.string().min(1),
        assignee: z.string().min(1),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        taskId: z.string(),
        assignee: z.string().optional(),
      })
      .strict(),
  },
  async (input: { repoPath?: string; taskId: string; assignee: string; commitMode: "none" | "local" | "push" }) => {
    const output = await updateTask({
      repoPath: input.repoPath,
      taskId: input.taskId,
      assignee: input.assignee,
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: output.repoRoot, taskId: output.task.taskId, assignee: output.task.assignee };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const taskMarkDoneTool = [
  "task_mark_done",
  {
    title: "Mark Task Done",
    description: "Convenience wrapper: sets status=done.",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        taskId: z.string().min(1),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        taskId: z.string(),
        status: z.literal("done"),
      })
      .strict(),
  },
  async (input: { repoPath?: string; taskId: string; commitMode: "none" | "local" | "push" }) => {
    const output = await updateTask({
      repoPath: input.repoPath,
      taskId: input.taskId,
      status: "done",
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: output.repoRoot, taskId: output.task.taskId, status: output.task.status as "done" };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const taskCancelTool = [
  "task_cancel",
  {
    title: "Cancel Task",
    description: "Convenience wrapper: sets status=canceled (shown as strikethrough in INDEX.md).",
    inputSchema: z
      .object({
        repoPath: z.string().optional(),
        taskId: z.string().min(1),
        commitMode: z.enum(["none", "local", "push"]).default("push"),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        taskId: z.string(),
        status: z.literal("canceled"),
      })
      .strict(),
  },
  async (input: { repoPath?: string; taskId: string; commitMode: "none" | "local" | "push" }) => {
    const output = await updateTask({
      repoPath: input.repoPath,
      taskId: input.taskId,
      status: "canceled",
      commitMode: input.commitMode,
    });
    const shaped = { repoRoot: output.repoRoot, taskId: output.task.taskId, status: output.task.status as "canceled" };
    return {
      content: [{ type: "text" as const, text: JSON.stringify(shaped) }],
      structuredContent: shaped,
    };
  },
] as const;

export const worktreeCreateTool = [
  "worktree_create",
  {
    title: "Create Git Worktree",
    description:
      "Creates a git worktree under ../work3/<repoSlug>/TIMESTAMP--desc--agent, creates a branch and pushes it to origin.",
    inputSchema: z
      .object({
        repoPath: z
          .string()
          .optional()
          .describe(
            "Path inside the repo (any file/dir). If omitted, uses current working directory of the MCP process."
          ),
        agentName: z.string().min(1),
        shortDesc: z.string().min(1),
        baseRef: z.string().default("main"),
        timestampLocal: z
          .string()
          .optional()
          .describe("Optional like 2026-02-02_13-36"),
        push: z
          .boolean()
          .default(true)
          .describe("If true, runs git push -u origin <branch>."),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        worktreePath: z.string(),
        branch: z.string(),
        repoSlug: z.string(),
      })
      .strict(),
  },
  async (input: WorktreeCreateInput) => {
    const output: WorktreeCreateOutput = await createWorktree(input);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

export const worktreeListTool = [
  "worktree_list",
  {
    title: "List Git Worktrees",
    description: "Lists git worktrees for the repository.",
    inputSchema: z
      .object({
        repoPath: z
          .string()
          .optional()
          .describe(
            "Path inside the repo (any file/dir). If omitted, uses current working directory of the MCP process."
          ),
      })
      .strict(),
    outputSchema: z
      .object({
        repoRoot: z.string(),
        worktrees: z.array(
          z
            .object({
              path: z.string(),
              head: z.string().optional(),
              branch: z.string().optional(),
              bare: z.boolean().optional(),
            })
            .strict()
        ),
      })
      .strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const output = await listWorktrees({ repoPath });
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

export const worktreeRemoveTool = [
  "worktree_remove",
  {
    title: "Remove Git Worktree",
    description:
      "Removes a worktree by path. Use this after PR merge (triggered externally).",
    inputSchema: z
      .object({
        worktreePath: z.string().min(1),
        force: z.boolean().default(false),
      })
      .strict(),
    outputSchema: z
      .object({
        removed: z.boolean(),
        worktreePath: z.string(),
      })
      .strict(),
  },
  async (input: { worktreePath: string; force: boolean }) => {
    const output = await removeWorktree(input);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(output) }],
      structuredContent: output,
    };
  },
] as const;

// ==================== SCAN SYSTEM MCPS ====================
export const scanSystemMcpsTool = [
  "scan_system_mcps",
  {
    title: "Scan System MCPs",
    description: "Scans system for installed MCP servers (Windsurf, Cursor, Claude Desktop, OpenCode).",
    inputSchema: z.object({}).strict(),
    outputSchema: z.object({
      mcps: z.array(z.object({ name: z.string(), source: z.string(), path: z.string().optional() })),
      ideClients: z.array(z.string()),
    }).strict(),
  },
  async () => {
    const out = await scanSystemMcps();
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const authorizeMcpsForSwarmTool = [
  "authorize_mcps_for_swarm",
  {
    title: "Authorize MCPs for Swarm",
    description: "Sets POLICY.json with list of authorized MCPs for all agents.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      authorizedMcps: z.array(z.string()),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ repoRoot: z.string(), policyPath: z.string() }).strict(),
  },
  async (input: { repoPath?: string; authorizedMcps: string[]; commitMode: "none" | "local" | "push" }) => {
    const out = await authorizeMcpsForSwarm(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getPolicyTool = [
  "get_policy",
  {
    title: "Get Swarm Policy",
    description: "Reads POLICY.json to see which MCPs are authorized.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ authorizedMcps: z.array(z.string()) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await getPolicy(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== FILE LOCKS ====================
export const fileReserveTool = [
  "file_reserve",
  {
    title: "Reserve File",
    description: "Locks a file (exclusive=write lock, non-exclusive=read lock). 1 writer, many readers.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      filePath: z.string().min(1),
      agent: z.string().min(1),
      exclusive: z.boolean().default(true),
      ttlMs: z.number().int().positive().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean(), lockedBy: z.string().optional(), lockPath: z.string() }).strict(),
  },
  async (input: { repoPath?: string; filePath: string; agent: string; exclusive: boolean; ttlMs?: number; commitMode: "none" | "local" | "push" }) => {
    const out = await fileReserve(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const fileReleaseTool = [
  "file_release",
  {
    title: "Release File Lock",
    description: "Releases a file lock held by this agent.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      filePath: z.string().min(1),
      agent: z.string().min(1),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; filePath: string; agent: string; commitMode: "none" | "local" | "push" }) => {
    const out = await fileRelease(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listFileLocksTool = [
  "list_file_locks",
  {
    title: "List File Locks",
    description: "Lists all active file locks in swarm/locks/.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ locks: z.array(z.object({ path: z.string(), agent: z.string(), exclusive: z.boolean(), exp: z.number() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const locks = await listFileLocks(repoPath);
    const out = { locks };
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== AUCTION ====================
export const announceTaskForBiddingTool = [
  "announce_task_for_bidding",
  {
    title: "Announce Task for Bidding",
    description: "Coordinator announces a task for agents to bid on.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskId: z.string().min(1),
      title: z.string().min(1),
      requiredCapabilities: z.array(z.string()).optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ eventId: z.string() }).strict(),
  },
  async (input: { repoPath?: string; taskId: string; title: string; requiredCapabilities?: string[]; commitMode: "none" | "local" | "push" }) => {
    const out = await announceTaskForBidding(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const bidForTaskTool = [
  "bid_for_task",
  {
    title: "Bid for Task",
    description: "Agent bids for a task with their capabilities.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskId: z.string().min(1),
      agent: z.string().min(1),
      capabilities: z.array(z.string()),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ eventId: z.string() }).strict(),
  },
  async (input: { repoPath?: string; taskId: string; agent: string; capabilities: string[]; commitMode: "none" | "local" | "push" }) => {
    const out = await bidForTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const pollSwarmEventsTool = [
  "poll_swarm_events",
  {
    title: "Poll Swarm Events",
    description: "Polls swarm/EVENTS.ndjson for new events since timestamp.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      since: z.number().optional(),
      types: z.array(z.string()).optional(),
    }).strict(),
    outputSchema: z.object({ events: z.array(z.object({ id: z.string(), ts: z.number(), type: z.string(), payload: z.unknown() })) }).strict(),
  },
  async (input: { repoPath?: string; since?: number; types?: string[] }) => {
    const out = await pollSwarmEvents(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== GITHUB PR ====================
export const createGithubPrTool = [
  "create_github_pr",
  {
    title: "Create GitHub PR",
    description: "Creates a GitHub Pull Request using gh CLI.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      title: z.string().min(1),
      body: z.string().optional(),
      baseBranch: z.string().optional(),
      draft: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({ repoRoot: z.string(), branch: z.string(), baseBranch: z.string(), prUrl: z.string().optional(), error: z.string().optional() }).strict(),
  },
  async (input: { repoPath?: string; title: string; body?: string; baseBranch?: string; draft?: boolean }) => {
    const out = await createGithubPr(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const checkMainHealthTool = [
  "check_main_health",
  {
    title: "Check Main Health (Rebase-Guard)",
    description: "Checks if base branch is healthy (tests pass) before rebase/merge.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      baseBranch: z.string().optional(),
    }).strict(),
    outputSchema: z.object({ healthy: z.boolean(), message: z.string() }).strict(),
  },
  async (input: { repoPath?: string; baseBranch?: string }) => {
    const out = await checkMainHealth(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== DEPENDENCY SYNC ====================
export const signalDependencyChangeTool = [
  "signal_dependency_change",
  {
    title: "Signal Dependency Change",
    description: "Signals that dependencies changed (npm/pip) so other agents can sync.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      type: z.enum(["npm", "pip", "other"]),
      added: z.array(z.string()),
      removed: z.array(z.string()).optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; type: "npm" | "pip" | "other"; added: string[]; removed?: string[]; commitMode: "none" | "local" | "push" }) => {
    const out = await signalDependencyChange(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const syncDependenciesTool = [
  "sync_dependencies",
  {
    title: "Sync Dependencies",
    description: "Runs npm install / pip install to sync dependencies locally.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ synced: z.array(z.string()), errors: z.array(z.string()) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await syncDependencies(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== CROSS-AGENT CODE REVIEW ====================
export const requestCrossAgentReviewTool = [
  "request_cross_agent_review",
  {
    title: "Request Cross-Agent Review",
    description: "Requests another agent to review code before user sees it.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      fromAgent: z.string().min(1),
      toAgent: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ reviewId: z.string(), reviewPath: z.string() }).strict(),
  },
  async (input: { repoPath?: string; fromAgent: string; toAgent?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await requestCrossAgentReview(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const respondToReviewTool = [
  "respond_to_review",
  {
    title: "Respond to Review",
    description: "Approves or rejects a cross-agent code review.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      reviewId: z.string().min(1),
      status: z.enum(["approved", "rejected"]),
      comment: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; reviewId: string; status: "approved" | "rejected"; comment?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await respondToReview(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listPendingReviewsTool = [
  "list_pending_reviews",
  {
    title: "List Pending Reviews",
    description: "Lists all pending cross-agent code reviews.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ reviews: z.array(z.object({ id: z.string(), fromAgent: z.string(), branch: z.string(), status: z.string() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const reviews = await listPendingReviews(repoPath);
    const out = { reviews: reviews.map(r => ({ id: r.id, fromAgent: r.fromAgent, branch: r.branch, status: r.status })) };
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== SCREENSHOT SHARING (Visual Brain) ====================
export const shareScreenshotTool = [
  "share_screenshot",
  {
    title: "Share Screenshot",
    description: "Shares a screenshot with other agents (Visual Brain).",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      imageBase64: z.string().min(1),
      description: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ id: z.string(), filePath: z.string() }).strict(),
  },
  async (input: { repoPath?: string; agent: string; imageBase64: string; description?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await shareScreenshot(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listScreenshotsTool = [
  "list_screenshots",
  {
    title: "List Screenshots",
    description: "Lists all shared screenshots.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ screenshots: z.array(z.object({ id: z.string(), agent: z.string(), filename: z.string(), description: z.string().optional(), ts: z.number() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const screenshots = await listScreenshots(repoPath);
    const out = { screenshots };
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== TASK DECOMPOSITION ====================
export const decomposeTaskTool = [
  "decompose_task",
  {
    title: "Decompose Task",
    description: "Breaks a large task into smaller subtasks for parallel work.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      parentTaskId: z.string().min(1),
      parentTitle: z.string().min(1),
      subtasks: z.array(z.object({
        title: z.string(),
        description: z.string().optional(),
        estimatedMinutes: z.number().optional(),
        dependencies: z.array(z.string()).optional(),
      })),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ parentTaskId: z.string(), subtasks: z.array(z.object({ id: z.string(), title: z.string() })), tasksJsonPath: z.string() }).strict(),
  },
  async (input: { repoPath?: string; parentTaskId: string; parentTitle: string; subtasks: Array<{ title: string; description?: string; estimatedMinutes?: number; dependencies?: string[] }>; commitMode: "none" | "local" | "push" }) => {
    const out = await decomposeTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getDecompositionTool = [
  "get_decomposition",
  {
    title: "Get Task Decomposition",
    description: "Gets the subtasks of a decomposed parent task.",
    inputSchema: z.object({ repoPath: z.string().optional(), parentTaskId: z.string().min(1) }).strict(),
    outputSchema: z.object({ found: z.boolean(), subtasks: z.array(z.object({ id: z.string(), title: z.string() })) }).strict(),
  },
  async (input: { repoPath?: string; parentTaskId: string }) => {
    const out = await getDecomposition(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== ARCHITECTURE VOTING ====================
export const startVotingTool = [
  "start_voting",
  {
    title: "Start Voting",
    description: "Initiates a vote for dangerous actions (delete folder, change core system, etc.).",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      initiator: z.string().min(1),
      action: z.string().min(1),
      description: z.string().min(1),
      dangerLevel: z.enum(["low", "medium", "high", "critical"]).optional(),
      ttlMinutes: z.number().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ votingId: z.string(), session: z.object({ status: z.string(), requiredApprovals: z.number() }) }).strict(),
  },
  async (input: { repoPath?: string; initiator: string; action: string; description: string; dangerLevel?: "low" | "medium" | "high" | "critical"; ttlMinutes?: number; commitMode: "none" | "local" | "push" }) => {
    const out = await startVoting(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const castVoteTool = [
  "cast_vote",
  {
    title: "Cast Vote",
    description: "Casts a vote (approve/reject) on an open voting session.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      votingId: z.string().min(1),
      agent: z.string().min(1),
      decision: z.enum(["approve", "reject"]),
      reason: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ success: z.boolean(), session: z.object({ status: z.string() }).nullable() }).strict(),
  },
  async (input: { repoPath?: string; votingId: string; agent: string; decision: "approve" | "reject"; reason?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await castVote(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listOpenVotingsTool = [
  "list_open_votings",
  {
    title: "List Open Votings",
    description: "Lists all open voting sessions.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ votings: z.array(z.object({ id: z.string(), action: z.string(), dangerLevel: z.string(), status: z.string() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const votings = await listOpenVotings(repoPath);
    const out = { votings: votings.map(v => ({ id: v.id, action: v.action, dangerLevel: v.dangerLevel, status: v.status })) };
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== REMOTE CLEANUP ====================
export const autoDeleteMergedBranchTool = [
  "auto_delete_merged_branch",
  {
    title: "Auto Delete Merged Branch",
    description: "Deletes a branch locally and/or on GitHub after merge.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      branch: z.string().min(1),
      deleteLocal: z.boolean().optional(),
      deleteRemote: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({ deletedLocal: z.boolean(), deletedRemote: z.boolean(), error: z.string().optional() }).strict(),
  },
  async (input: { repoPath?: string; branch: string; deleteLocal?: boolean; deleteRemote?: boolean }) => {
    const out = await autoDeleteMergedBranch(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const cleanupAllMergedBranchesTool = [
  "cleanup_all_merged_branches",
  {
    title: "Cleanup All Merged Branches",
    description: "Deletes all branches that have been merged into main.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      deleteLocal: z.boolean().optional(),
      deleteRemote: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({ cleaned: z.array(z.string()), errors: z.array(z.string()) }).strict(),
  },
  async (input: { repoPath?: string; deleteLocal?: boolean; deleteRemote?: boolean }) => {
    const out = await cleanupAllMergedBranches(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== SWARM THOUGHTS ====================
export const logSwarmThoughtTool = [
  "log_swarm_thought",
  {
    title: "Log Swarm Thought",
    description: "Logs reasoning/decision to SWARM_THOUGHTS.md collective knowledge base.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      taskId: z.string().optional(),
      thought: z.string().min(1),
      context: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; agent: string; taskId?: string; thought: string; context?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await logSwarmThought(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getRecentThoughtsTool = [
  "get_recent_thoughts",
  {
    title: "Get Recent Thoughts",
    description: "Gets recent entries from SWARM_THOUGHTS.md.",
    inputSchema: z.object({ repoPath: z.string().optional(), limit: z.number().optional() }).strict(),
    outputSchema: z.object({ thoughts: z.array(z.object({ agent: z.string(), thought: z.string(), ts: z.number() })) }).strict(),
  },
  async (input: { repoPath?: string; limit?: number }) => {
    const thoughts = await getRecentThoughts(input);
    const out = { thoughts };
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== GHOST MODE (PATROL) ====================
export const patrolModeTool = [
  "patrol_mode",
  {
    title: "Patrol Mode (Ghost)",
    description: "When idle, patrol codebase: run linters, check imports, suggest optimizations.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      runLint: z.boolean().optional(),
      checkImports: z.boolean().optional(),
      checkOptimizations: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({ lintErrors: z.number(), lintFixed: z.number(), unusedImports: z.array(z.string()), suggestedOptimizations: z.array(z.string()), filesChecked: z.number() }).strict(),
  },
  async (input: { repoPath?: string; runLint?: boolean; checkImports?: boolean; checkOptimizations?: boolean }) => {
    const out = await patrolMode(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== IMMUNE SYSTEM ====================
export const reportCiAlertTool = [
  "report_ci_alert",
  {
    title: "Report CI Alert",
    description: "Reports a CI failure or test error to trigger immune response.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      level: z.enum(["info", "warning", "error", "critical"]),
      source: z.string().min(1),
      message: z.string().min(1),
      details: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ alertId: z.string() }).strict(),
  },
  async (input: { repoPath?: string; level: "info" | "warning" | "error" | "critical"; source: string; message: string; details?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await reportCiAlert(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getImmuneStatusTool = [
  "get_immune_status",
  {
    title: "Get Immune Status",
    description: "Checks if project is healthy or has active CI alerts.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ healthy: z.boolean(), alerts: z.array(z.object({ id: z.string(), level: z.string(), message: z.string() })), lastCheck: z.number() }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await getImmuneStatus(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const runLocalTestsTool = [
  "run_local_tests",
  {
    title: "Run Local Tests",
    description: "Runs npm test locally to check project health.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ passed: z.boolean(), output: z.string() }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await runLocalTests(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== CONFLICT FORECASTING ====================
export const forecastFileTouchesTool = [
  "forecast_file_touches",
  {
    title: "Forecast File Touches",
    description: "Announces which files agent plans to modify soon, so others can avoid conflicts.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      taskId: z.string().optional(),
      files: z.array(z.string()),
      estimatedMinutesFromNow: z.number().optional(),
      confidence: z.enum(["low", "medium", "high"]).optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ forecastId: z.string() }).strict(),
  },
  async (input: { repoPath?: string; agent: string; taskId?: string; files: string[]; estimatedMinutesFromNow?: number; confidence?: "low" | "medium" | "high"; commitMode: "none" | "local" | "push" }) => {
    const out = await forecastFileTouches(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const checkFileConflictsTool = [
  "check_file_conflicts",
  {
    title: "Check File Conflicts",
    description: "Checks if files you want to edit are forecasted by another agent.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      files: z.array(z.string()),
      excludeAgent: z.string().optional(),
    }).strict(),
    outputSchema: z.object({ conflicts: z.array(z.object({ file: z.string(), forecastedBy: z.string(), estimatedTime: z.number() })) }).strict(),
  },
  async (input: { repoPath?: string; files: string[]; excludeAgent?: string }) => {
    const out = await checkFileConflicts(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== CROSS-PLATFORM UI VALIDATOR ====================
export const requestPlatformCheckTool = [
  "request_platform_check",
  {
    title: "Request Platform Check",
    description: "Requests other agents on different platforms to verify UI/functionality.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      fromAgent: z.string().min(1),
      targetPlatforms: z.array(z.string()).optional(),
      component: z.string().min(1),
      description: z.string().optional(),
      screenshotBase64: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ checkId: z.string(), request: z.object({ status: z.string() }) }).strict(),
  },
  async (input: { repoPath?: string; fromAgent: string; targetPlatforms?: string[]; component: string; description?: string; screenshotBase64?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await requestPlatformCheck(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const respondToPlatformCheckTool = [
  "respond_to_platform_check",
  {
    title: "Respond to Platform Check",
    description: "Responds to a cross-platform check request with ok/issue.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      checkId: z.string().min(1),
      agent: z.string().min(1),
      result: z.enum(["ok", "issue"]),
      issueDescription: z.string().optional(),
      screenshotBase64: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; checkId: string; agent: string; result: "ok" | "issue"; issueDescription?: string; screenshotBase64?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await respondToPlatformCheck(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getPendingPlatformChecksTool = [
  "get_pending_platform_checks",
  {
    title: "Get Pending Platform Checks",
    description: "Gets platform checks waiting for response from current platform.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ checks: z.array(z.object({ id: z.string(), component: z.string(), fromAgent: z.string() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const checks = await getPendingPlatformChecks(repoPath);
    const out = { checks: checks.map(c => ({ id: c.id, component: c.component, fromAgent: c.fromAgent })) };
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== BRIEFING HANDOVER ====================
export const saveBriefingTool = [
  "save_briefing",
  {
    title: "Save Briefing",
    description: "Saves a mental snapshot before ending session or switching tasks.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskId: z.string().optional(),
      agent: z.string().min(1),
      filesWorkedOn: z.array(z.string()),
      currentState: z.string().min(1),
      nextSteps: z.array(z.string()),
      blockers: z.array(z.string()).optional(),
      notes: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ briefingId: z.string(), briefingPath: z.string() }).strict(),
  },
  async (input: any) => {
    const out = await saveBriefing(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const loadBriefingTool = [
  "load_briefing",
  {
    title: "Load Briefing",
    description: "Loads briefings for a task to continue from another agent's snapshot.",
    inputSchema: z.object({ repoPath: z.string().optional(), taskId: z.string().optional(), agent: z.string().optional() }).strict(),
    outputSchema: z.object({ briefings: z.array(z.any()) }).strict(),
  },
  async (input: any) => {
    const out = await loadBriefing(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== SWARM PULSE ====================
export const updateSwarmPulseTool = [
  "update_swarm_pulse",
  {
    title: "Update Swarm Pulse",
    description: "Updates your status in the live agent map PULSE.md. Call after every action!",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      currentFile: z.string().optional(),
      currentTask: z.string().optional(),
      status: z.enum(["active", "idle", "paused", "offline"]),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ updated: z.boolean() }).strict(),
  },
  async (input: any) => {
    const out = await updateSwarmPulse(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getSwarmPulseTool = [
  "get_swarm_pulse",
  {
    title: "Get Swarm Pulse",
    description: "Gets the current live agent map showing who is working on what.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ agents: z.array(z.any()), lastUpdate: z.number() }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await getSwarmPulse(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== KNOWLEDGE BASE ====================
export const archiveFindingTool = [
  "archive_finding",
  {
    title: "Archive Finding",
    description: "Archives a bug fix or discovery to the collective knowledge base.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      category: z.enum(["bug", "workaround", "optimization", "library", "config", "other"]),
      title: z.string().min(1),
      description: z.string().min(1),
      solution: z.string().optional(),
      relatedFiles: z.array(z.string()).optional(),
      tags: z.array(z.string()).optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ entryId: z.string() }).strict(),
  },
  async (input: any) => {
    const out = await archiveFinding(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const searchKnowledgeTool = [
  "search_knowledge",
  {
    title: "Search Knowledge Base",
    description: "Searches the collective knowledge base for solutions.",
    inputSchema: z.object({ repoPath: z.string().optional(), query: z.string().optional(), category: z.string().optional(), tags: z.array(z.string()).optional() }).strict(),
    outputSchema: z.object({ entries: z.array(z.any()) }).strict(),
  },
  async (input: any) => {
    const out = await searchKnowledge(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== URGENT PREEMPTION ====================
export const triggerUrgentPreemptionTool = [
  "trigger_urgent_preemption",
  {
    title: "Trigger Urgent Preemption",
    description: "Forces other agents to release files for critical bug fix.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskId: z.string().min(1),
      title: z.string().min(1),
      reason: z.string().min(1),
      initiator: z.string().min(1),
      affectedFiles: z.array(z.string()),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ urgentId: z.string(), preemptedAgents: z.array(z.string()) }).strict(),
  },
  async (input: any) => {
    const out = await triggerUrgentPreemption(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getActiveUrgentTool = [
  "get_active_urgent",
  {
    title: "Get Active Urgent",
    description: "Checks if there is an active URGENT task that should preempt your work.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ urgent: z.any().nullable() }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const urgent = await getActiveUrgent(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify({ urgent }) }], structuredContent: { urgent } };
  },
] as const;

// ==================== SNAPSHOT & ROLLBACK ====================
export const createSnapshotTool = [
  "create_snapshot",
  {
    title: "Create Snapshot",
    description: "Creates a snapshot of files before risky changes for rollback.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      taskId: z.string().optional(),
      files: z.array(z.string()),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ snapshotId: z.string(), snapshotPath: z.string() }).strict(),
  },
  async (input: any) => {
    const out = await createSnapshot(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const triggerRollbackTool = [
  "trigger_rollback",
  {
    title: "Trigger Rollback",
    description: "Restores files from snapshot when changes failed or user rejected.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      snapshotId: z.string().min(1),
      agent: z.string().min(1),
      reason: z.string().min(1),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ rolledBack: z.boolean(), filesRestored: z.array(z.string()) }).strict(),
  },
  async (input: any) => {
    const out = await triggerRollback(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== COLLECTIVE ADVICE ====================
export const requestCollectiveAdviceTool = [
  "request_collective_advice",
  {
    title: "Request Collective Advice",
    description: "When stuck after rollback, request help from all agents.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      taskId: z.string().optional(),
      problem: z.string().min(1),
      context: z.string().min(1),
      codeSnippet: z.string().optional(),
      filesInvolved: z.array(z.string()),
      attemptedSolutions: z.array(z.string()),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ requestId: z.string() }).strict(),
  },
  async (input: any) => {
    const out = await requestCollectiveAdvice(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const provideAdviceTool = [
  "provide_advice",
  {
    title: "Provide Advice",
    description: "Responds to another agent's request for collective advice.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      requestId: z.string().min(1),
      agent: z.string().min(1),
      suggestion: z.string().min(1),
      confidence: z.enum(["low", "medium", "high"]),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ ok: z.boolean() }).strict(),
  },
  async (input: any) => {
    const out = await provideAdvice(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== AUTO-DOCUMENTATION ====================
export const autoGenerateDocsTool = [
  "auto_generate_docs",
  {
    title: "Auto Generate Docs",
    description: "Generates documentation for a completed feature automatically.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      taskId: z.string().min(1),
      feature: z.string().min(1),
      description: z.string().min(1),
      usage: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ docId: z.string(), docPath: z.string() }).strict(),
  },
  async (input: any) => {
    const out = await autoGenerateDocs(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== AGENT SPECIALIZATION ====================
export const trackExpertiseTool = [
  "track_expertise",
  {
    title: "Track Expertise",
    description: "Records which files you edited to build specialization profile.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      filesEdited: z.array(z.string()),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ updated: z.boolean() }).strict(),
  },
  async (input: any) => {
    const out = await trackExpertise(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const suggestAgentForTaskTool = [
  "suggest_agent_for_task",
  {
    title: "Suggest Agent for Task",
    description: "Suggests best agent for a task based on expertise history.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskDescription: z.string().min(1),
      filesLikelyInvolved: z.array(z.string()).optional(),
    }).strict(),
    outputSchema: z.object({ suggestedAgents: z.array(z.object({ agent: z.string(), score: z.number(), reason: z.string() })) }).strict(),
  },
  async (input: any) => {
    const out = await suggestAgentForTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== CONFLICT PREDICTION ====================
export const predictConflictsTool = [
  "predict_conflicts",
  {
    title: "Predict Conflicts",
    description: "Analyzes Git history to predict merge conflict risk for files.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      filesToEdit: z.array(z.string()),
    }).strict(),
    outputSchema: z.object({ predictions: z.array(z.object({ file: z.string(), conflictScore: z.number(), reason: z.string() })) }).strict(),
  },
  async (input: any) => {
    const out = await predictConflicts(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.4.1: ENHANCED AUTO-DOCUMENTATION ====================
export const generateTaskDocsTool = [
  "generate_task_docs",
  {
    title: "Generate Task Documentation",
    description: "Auto-generates documentation with diffs and summaries when a task is completed. Stores in swarm/docs/.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskId: z.string().min(1),
      taskTitle: z.string().min(1),
      agent: z.string().min(1),
      filesModified: z.array(z.string()),
      summary: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ docPath: z.string(), indexUpdated: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; taskId: string; taskTitle: string; agent: string; filesModified: string[]; summary?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await generateTaskDocumentation(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listDocsTool = [
  "list_task_docs",
  {
    title: "List Task Documentation",
    description: "Lists all auto-generated documentation files with index.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ docs: z.array(z.object({ id: z.string(), taskId: z.string(), title: z.string(), agent: z.string() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await listDocumentation(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getDocTool = [
  "get_task_doc",
  {
    title: "Get Task Documentation",
    description: "Gets full documentation content for a specific task.",
    inputSchema: z.object({ repoPath: z.string().optional(), taskId: z.string().min(1) }).strict(),
    outputSchema: z.object({ found: z.boolean(), content: z.string() }).strict(),
  },
  async (input: { repoPath?: string; taskId: string }) => {
    const out = await getDocumentation(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.4.1: ENHANCED AGENT SPECIALIZATION ====================
export const recordAgentEditTool = [
  "record_agent_edit",
  {
    title: "Record Agent Edit",
    description: "Records file edits to build agent expertise profile. Called after each edit session.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      files: z.array(z.string()),
      taskKeywords: z.array(z.string()).optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ recorded: z.boolean(), agent: z.string(), totalEdits: z.number() }).strict(),
  },
  async (input: { repoPath?: string; agent: string; files: string[]; taskKeywords?: string[]; commitMode: "none" | "local" | "push" }) => {
    const out = await recordAgentEdit(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const suggestAgentAdvancedTool = [
  "suggest_agent_advanced",
  {
    title: "Suggest Agent (Advanced)",
    description: "ML-based agent suggestion based on expertise history for files, directories, and keywords.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      files: z.array(z.string()).optional(),
      directories: z.array(z.string()).optional(),
      keywords: z.array(z.string()).optional(),
    }).strict(),
    outputSchema: z.object({ suggestions: z.array(z.object({ agent: z.string(), score: z.number(), reason: z.string(), expertise: z.array(z.string()) })) }).strict(),
  },
  async (input: { repoPath?: string; files?: string[]; directories?: string[]; keywords?: string[] }) => {
    const out = await suggestAgentAdvanced(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getTopExpertsTool = [
  "get_top_experts",
  {
    title: "Get Top Experts",
    description: "Gets agents who are experts in a specific area (file path, directory, or keyword).",
    inputSchema: z.object({ repoPath: z.string().optional(), area: z.string().min(1), limit: z.number().optional() }).strict(),
    outputSchema: z.object({ experts: z.array(z.object({ agent: z.string(), edits: z.number() })) }).strict(),
  },
  async (input: { repoPath?: string; area: string; limit?: number }) => {
    const out = await getTopExperts(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listAgentExpertiseTool = [
  "list_all_agent_expertise",
  {
    title: "List All Agent Expertise",
    description: "Lists all agents with their expertise stats and top areas.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ agents: z.array(z.object({ agent: z.string(), totalEdits: z.number(), topAreas: z.array(z.string()), lastSeen: z.string() })) }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await listAllAgentExpertise(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.4.1: ENHANCED CONFLICT PREDICTION ====================
export const analyzeConflictHistoryTool = [
  "analyze_conflict_history",
  {
    title: "Analyze Conflict History",
    description: "Analyzes git history to find conflict-prone files (hotspots). Run periodically.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      lookbackDays: z.number().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ analyzed: z.boolean(), filesScanned: z.number(), hotspots: z.array(z.string()) }).strict(),
  },
  async (input: { repoPath?: string; lookbackDays?: number; commitMode: "none" | "local" | "push" }) => {
    const out = await analyzeConflictHistory(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getConflictHotspotsTool = [
  "get_conflict_hotspots",
  {
    title: "Get Conflict Hotspots",
    description: "Gets list of files most likely to cause merge conflicts.",
    inputSchema: z.object({ repoPath: z.string().optional(), limit: z.number().optional() }).strict(),
    outputSchema: z.object({ hotspots: z.array(z.object({ filePath: z.string(), hotspotScore: z.number(), conflictCount: z.number(), contributors: z.array(z.string()) })) }).strict(),
  },
  async (input: { repoPath?: string; limit?: number }) => {
    const out = await getConflictHotspots(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const checkFileSafetyTool = [
  "check_file_safety",
  {
    title: "Check File Safety",
    description: "Checks if a file is safe to edit based on conflict history and current activity.",
    inputSchema: z.object({ repoPath: z.string().optional(), file: z.string().min(1), agent: z.string().min(1) }).strict(),
    outputSchema: z.object({ safe: z.boolean(), warning: z.string().nullable(), suggestedAction: z.string() }).strict(),
  },
  async (input: { repoPath?: string; file: string; agent: string }) => {
    const out = await checkFileSafety(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const recordConflictEventTool = [
  "record_conflict_event",
  {
    title: "Record Conflict Event",
    description: "Records when a merge conflict happens for ML learning and prediction improvement.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      file: z.string().min(1),
      agent: z.string().min(1),
      resolved: z.boolean(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({ recorded: z.boolean() }).strict(),
  },
  async (input: { repoPath?: string; file: string; agent: string; resolved: boolean; commitMode: "none" | "local" | "push" }) => {
    const out = await recordConflictEvent(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== TIMELINE VISUALIZATION ====================
export const generateTimelineTool = [
  "generate_timeline",
  {
    title: "Generate Timeline",
    description: "Generates a visual timeline of all swarm activity (briefings, pulses, knowledge, tasks). Creates TIMELINE.md.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      since: z.number().optional().describe("Unix timestamp, defaults to last 24 hours"),
      limit: z.number().optional().describe("Max entries, defaults to 100"),
    }).strict(),
    outputSchema: z.object({ timeline: z.array(z.any()), generated: z.string() }).strict(),
  },
  async (input: { repoPath?: string; since?: number; limit?: number }) => {
    const out = await generateTimeline(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getTimelineVisualizationTool = [
  "get_timeline_visualization",
  {
    title: "Get Timeline Visualization",
    description: "Returns the current TIMELINE.md content.",
    inputSchema: z.object({ repoPath: z.string().optional() }).strict(),
    outputSchema: z.object({ markdown: z.string() }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const markdown = await getTimelineVisualization(repoPath);
    return { content: [{ type: "text" as const, text: JSON.stringify({ markdown }) }], structuredContent: { markdown } };
  },
] as const;

// ==================== v0.5: AGENT HEALTH MONITOR ====================
export const checkAgentHealthTool = [
  "check_agent_health",
  {
    title: "Check Agent Health",
    description: "Checks if agent is alive based on last ping time. Dead if > 30 min inactive.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      thresholdMinutes: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      alive: z.boolean(),
      lastSeen: z.string(),
      minutesAgo: z.number(),
      status: z.string(),
      currentTask: z.string().nullable(),
    }).strict(),
  },
  async (input: { repoPath?: string; agent: string; thresholdMinutes?: number }) => {
    const out = await checkAgentHealth(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getDeadAgentsTool = [
  "get_dead_agents",
  {
    title: "Get Dead Agents",
    description: "Gets list of inactive agents (dead if no ping > threshold).",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      thresholdMinutes: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      deadAgents: z.array(z.object({ agent: z.string(), lastSeen: z.string(), minutesAgo: z.number(), lastTask: z.string().nullable() })),
      aliveCount: z.number(),
      deadCount: z.number(),
    }).strict(),
  },
  async (input: { repoPath?: string; thresholdMinutes?: number }) => {
    const out = await getDeadAgents(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const forceReassignTaskTool = [
  "force_reassign_task",
  {
    title: "Force Reassign Task",
    description: "Reassigns a task from a dead agent to another agent or unassigns it.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      taskId: z.string().min(1),
      fromAgent: z.string().min(1),
      toAgent: z.string().optional(),
      reason: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      reassigned: z.boolean(),
      taskId: z.string(),
      fromAgent: z.string(),
      toAgent: z.string().nullable(),
      reason: z.string(),
    }).strict(),
  },
  async (input: { repoPath?: string; taskId: string; fromAgent: string; toAgent?: string; reason?: string; commitMode: "none" | "local" | "push" }) => {
    const out = await forceReassignTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getSwarmHealthSummaryTool = [
  "get_swarm_health_summary",
  {
    title: "Get Swarm Health Summary",
    description: "Gets overall health statistics of the swarm.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      thresholdMinutes: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      totalAgents: z.number(),
      aliveAgents: z.number(),
      deadAgents: z.number(),
      idleAgents: z.number(),
      activeAgents: z.number(),
      healthPercentage: z.number(),
      lastUpdate: z.string(),
    }).strict(),
  },
  async (input: { repoPath?: string; thresholdMinutes?: number }) => {
    const out = await getSwarmHealthSummary(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.5: SESSION RECORDING ====================
export const startSessionRecordingTool = [
  "start_session_recording",
  {
    title: "Start Session Recording",
    description: "Starts recording all agent actions to NDJSON file for replay/training.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      taskId: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      sessionId: z.string(),
      recordingPath: z.string(),
    }).strict(),
  },
  async (input: { repoPath?: string; agent: string; taskId?: string }) => {
    const out = await startSessionRecording(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const logSessionActionTool = [
  "log_session_action",
  {
    title: "Log Session Action",
    description: "Logs an action (tool call, file edit, etc.) to the current session.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      sessionId: z.string().min(1),
      actionType: z.enum(["tool_call", "file_edit", "file_read", "git_op", "chat", "error", "custom"]),
      tool: z.string().optional(),
      file: z.string().optional(),
      inputData: z.record(z.unknown()).optional(),
      outputData: z.string().optional(),
      duration: z.number().optional(),
      error: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      logged: z.boolean(),
      actionIndex: z.number(),
    }).strict(),
  },
  async (input: any) => {
    const out = await logSessionAction(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const stopSessionRecordingTool = [
  "stop_session_recording",
  {
    title: "Stop Session Recording",
    description: "Stops the current session recording.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      sessionId: z.string().min(1),
      summary: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      stopped: z.boolean(),
      duration: z.number(),
      actionsCount: z.number(),
    }).strict(),
  },
  async (input: { repoPath?: string; sessionId: string; summary?: string }) => {
    const out = await stopSessionRecording(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listSessionRecordingsTool = [
  "list_session_recordings",
  {
    title: "List Session Recordings",
    description: "Lists all recorded sessions.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().optional(),
      limit: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      sessions: z.array(z.object({
        sessionId: z.string(),
        agent: z.string(),
        startedAt: z.string(),
        endedAt: z.string().nullable(),
        duration: z.number().nullable(),
        actionsCount: z.number(),
        taskId: z.string().nullable(),
      })),
    }).strict(),
  },
  async (input: { repoPath?: string; agent?: string; limit?: number }) => {
    const out = await listSessionRecordings(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const replaySessionTool = [
  "replay_session",
  {
    title: "Replay Session",
    description: "Reads session recording for replay or analysis.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      sessionId: z.string().min(1),
      fromIndex: z.number().optional(),
      toIndex: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      found: z.boolean(),
      meta: z.any().nullable(),
      actions: z.array(z.any()),
      totalActions: z.number(),
    }).strict(),
  },
  async (input: { repoPath?: string; sessionId: string; fromIndex?: number; toIndex?: number }) => {
    const out = await replaySession(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.5: QUALITY GATE ====================
export const runQualityGateTool = [
  "run_quality_gate",
  {
    title: "Run Quality Gate",
    description: "Runs lint + tests + type-check and generates quality report.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      runLint: z.boolean().optional(),
      runTests: z.boolean().optional(),
      runTypeCheck: z.boolean().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      timestamp: z.number(),
      branch: z.string(),
      lintErrors: z.number(),
      lintWarnings: z.number(),
      testsTotal: z.number(),
      testsPassed: z.number(),
      testsFailed: z.number(),
      testsSkipped: z.number(),
      typeCheckPassed: z.boolean(),
      typeCheckErrors: z.number(),
      overallPassed: z.boolean(),
      details: z.string(),
    }).passthrough(),
  },
  async (input: any) => {
    const out = await runQualityGate(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: { ...out } as Record<string, unknown> };
  },
] as const;

export const getQualityReportTool = [
  "get_quality_report",
  {
    title: "Get Quality Report",
    description: "Gets the latest quality report for a branch.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      branch: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      found: z.boolean(),
      report: z.any().nullable(),
    }).strict(),
  },
  async (input: { repoPath?: string; branch?: string }) => {
    const out = await getQualityReport(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const setQualityThresholdTool = [
  "set_quality_threshold",
  {
    title: "Set Quality Threshold",
    description: "Sets minimum quality requirements for PR readiness.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      maxLintErrors: z.number().optional(),
      maxLintWarnings: z.number().optional(),
      minTestCoverage: z.number().optional(),
      requireAllTestsPass: z.boolean().optional(),
      requireTypeCheck: z.boolean().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      updated: z.boolean(),
      threshold: z.object({
        maxLintErrors: z.number(),
        maxLintWarnings: z.number(),
        minTestCoverage: z.number(),
        requireAllTestsPass: z.boolean(),
        requireTypeCheck: z.boolean(),
      }),
    }).strict(),
  },
  async (input: any) => {
    const out = await setQualityThreshold(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const checkPrReadyTool = [
  "check_pr_ready",
  {
    title: "Check PR Ready",
    description: "Checks if the current branch is ready for a Pull Request.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      branch: z.string().optional(),
      runFreshCheck: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({
      ready: z.boolean(),
      issues: z.array(z.string()),
      report: z.any().nullable(),
    }).strict(),
  },
  async (input: { repoPath?: string; branch?: string; runFreshCheck?: boolean }) => {
    const out = await checkPrReady(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.5: COST TRACKER ====================
export const logApiUsageTool = [
  "log_api_usage",
  {
    title: "Log API Usage",
    description: "Logs token usage and cost for tracking.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      model: z.string().min(1),
      inputTokens: z.number(),
      outputTokens: z.number(),
      taskId: z.string().optional(),
      tool: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      logged: z.boolean(),
      cost: z.number(),
      totalTokens: z.number(),
    }).strict(),
  },
  async (input: any) => {
    const out = await logApiUsage(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getAgentCostsTool = [
  "get_agent_costs",
  {
    title: "Get Agent Costs",
    description: "Gets cost breakdown for a specific agent.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().min(1),
      periodDays: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      agent: z.string(),
      periodDays: z.number(),
      totalCost: z.number(),
      totalTokens: z.number(),
      requestCount: z.number(),
      breakdown: z.array(z.object({ model: z.string(), cost: z.number(), tokens: z.number(), count: z.number() })),
    }).strict(),
  },
  async (input: { repoPath?: string; agent: string; periodDays?: number }) => {
    const out = await getAgentCosts(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getProjectCostsTool = [
  "get_project_costs",
  {
    title: "Get Project Costs",
    description: "Gets total project costs with breakdown by agent and day.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      periodDays: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      periodDays: z.number(),
      totalCost: z.number(),
      totalTokens: z.number(),
      requestCount: z.number(),
      byAgent: z.array(z.object({ agent: z.string(), cost: z.number(), tokens: z.number(), count: z.number() })),
      byDay: z.array(z.object({ date: z.string(), cost: z.number(), tokens: z.number() })),
    }).strict(),
  },
  async (input: { repoPath?: string; periodDays?: number }) => {
    const out = await getProjectCosts(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const setBudgetLimitTool = [
  "set_budget_limit",
  {
    title: "Set Budget Limit",
    description: "Sets daily/monthly budget limits for cost control.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      dailyLimit: z.number().optional(),
      monthlyLimit: z.number().optional(),
      perAgentLimit: z.number().optional(),
      alertThreshold: z.number().optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      updated: z.boolean(),
      budget: z.object({
        dailyLimit: z.number(),
        monthlyLimit: z.number(),
        perAgentLimit: z.number(),
        alertThreshold: z.number(),
        currency: z.string(),
      }),
    }).strict(),
  },
  async (input: any) => {
    const out = await setBudgetLimit(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const checkBudgetRemainingTool = [
  "check_budget_remaining",
  {
    title: "Check Budget Remaining",
    description: "Checks how much budget is remaining.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      agent: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      dailyRemaining: z.number(),
      monthlyRemaining: z.number(),
      agentRemaining: z.number().nullable(),
      dailyUsed: z.number(),
      monthlyUsed: z.number(),
      agentUsed: z.number().nullable(),
      alerts: z.array(z.string()),
    }).strict(),
  },
  async (input: { repoPath?: string; agent?: string }) => {
    const out = await checkBudgetRemaining(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.5: CONTEXT COMPRESSOR ====================
export const estimateContextSizeTool = [
  "estimate_context_size",
  {
    title: "Estimate Context Size",
    description: "Estimates text size in tokens (chars/4 approximation).",
    inputSchema: z.object({
      text: z.string(),
      model: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      characters: z.number(),
      words: z.number(),
      lines: z.number(),
      tokensEstimated: z.number(),
      model: z.string(),
    }).strict(),
  },
  async (input: { text: string; model?: string }) => {
    const out = await estimateContextSize(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const compressBriefingTool = [
  "compress_briefing",
  {
    title: "Compress Briefing",
    description: "Compresses a briefing by removing duplicates and truncating if needed.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      briefing: z.string(),
      maxTokens: z.number().optional(),
      preserveCode: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({
      compressed: z.string(),
      stats: z.object({
        originalSize: z.number(),
        compressedSize: z.number(),
        compressionRatio: z.number(),
        tokensEstimated: z.number(),
        savedTokens: z.number(),
      }),
    }).strict(),
  },
  async (input: { repoPath?: string; briefing: string; maxTokens?: number; preserveCode?: boolean }) => {
    const out = await compressBriefing(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const compressMultipleBriefingsTool = [
  "compress_multiple_briefings",
  {
    title: "Compress Multiple Briefings",
    description: "Merges and compresses multiple briefings into one summary.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      briefings: z.array(z.string()),
      maxTokens: z.number().optional(),
    }).strict(),
    outputSchema: z.object({
      merged: z.string(),
      stats: z.object({
        originalSize: z.number(),
        compressedSize: z.number(),
        compressionRatio: z.number(),
        tokensEstimated: z.number(),
        savedTokens: z.number(),
      }),
      briefingsCount: z.number(),
    }).strict(),
  },
  async (input: { repoPath?: string; briefings: string[]; maxTokens?: number }) => {
    const out = await compressMultipleBriefings(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getCompressionStatsTool = [
  "get_compression_stats",
  {
    title: "Get Compression Stats",
    description: "Gets compression statistics for all project briefings.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      totalBriefings: z.number(),
      totalOriginalTokens: z.number(),
      totalCompressedTokens: z.number(),
      averageCompressionRatio: z.number(),
      potentialSavings: z.number(),
    }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await getCompressionStats({ repoPath });
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ==================== v0.5: REGRESSION DETECTOR ====================
export const saveBaselineTool = [
  "save_baseline",
  {
    title: "Save Baseline",
    description: "Saves current test/lint/type state as a baseline for comparison.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      name: z.string().min(1),
      agent: z.string().min(1),
      metrics: z.record(z.number()).optional(),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      baselineId: z.string(),
      baselinePath: z.string(),
      baseline: z.any(),
    }).strict(),
  },
  async (input: any) => {
    const out = await saveBaseline(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const checkRegressionTool = [
  "check_regression",
  {
    title: "Check Regression",
    description: "Compares current state with baseline to detect regressions.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      baselineName: z.string().min(1),
      agent: z.string().min(1),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      hasRegression: z.boolean(),
      regressions: z.array(z.object({ type: z.string(), description: z.string(), severity: z.string() })),
      comparison: z.object({
        testsTotal: z.object({ baseline: z.number(), current: z.number() }),
        testsPassed: z.object({ baseline: z.number(), current: z.number() }),
        lintErrors: z.object({ baseline: z.number(), current: z.number() }),
        typeCheckPassed: z.object({ baseline: z.boolean(), current: z.boolean() }),
      }),
    }).strict(),
  },
  async (input: { repoPath?: string; baselineName: string; agent: string; commitMode: "none" | "local" | "push" }) => {
    const out = await checkRegression(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listRegressionsTool = [
  "list_regressions",
  {
    title: "List Regressions",
    description: "Lists all detected regressions.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      includeResolved: z.boolean().optional(),
    }).strict(),
    outputSchema: z.object({
      regressions: z.array(z.any()),
      unresolvedCount: z.number(),
      totalCount: z.number(),
    }).strict(),
  },
  async (input: { repoPath?: string; includeResolved?: boolean }) => {
    const out = await listRegressions(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const resolveRegressionTool = [
  "resolve_regression",
  {
    title: "Resolve Regression",
    description: "Marks a regression as resolved.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
      regressionId: z.string().min(1),
      agent: z.string().min(1),
      commitMode: z.enum(["none", "local", "push"]).default("push"),
    }).strict(),
    outputSchema: z.object({
      resolved: z.boolean(),
      regression: z.any().nullable(),
    }).strict(),
  },
  async (input: { repoPath?: string; regressionId: string; agent: string; commitMode: "none" | "local" | "push" }) => {
    const out = await resolveRegression(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listBaselinesTool = [
  "list_baselines",
  {
    title: "List Baselines",
    description: "Lists all saved baselines.",
    inputSchema: z.object({
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      baselines: z.array(z.object({
        name: z.string(),
        createdAt: z.string(),
        createdBy: z.string(),
        branch: z.string(),
        testsPassed: z.number(),
      })),
    }).strict(),
  },
  async ({ repoPath }: { repoPath?: string }) => {
    const out = await listBaselines({ repoPath });
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ============================================================================
// v0.6 Brainstorming Tools (superpowers-inspired)
// ============================================================================

export const startBrainstormTool = [
  "start_brainstorm",
  {
    title: "Start Brainstorm",
    description: "Starts a brainstorming session for design refinement. Ask questions one at a time to understand requirements before designing.",
    inputSchema: z.object({
      agentId: z.string().min(1),
      taskId: z.string().optional(),
      taskDescription: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      session: z.any(),
      nextStep: z.string(),
      suggestedQuestions: z.array(z.any()),
    }).strict(),
  },
  (input: { agentId: string; taskId?: string; taskDescription?: string; repoPath?: string }) => {
    const out = startBrainstorm(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const askBrainstormQuestionTool = [
  "ask_brainstorm_question",
  {
    title: "Ask Brainstorm Question",
    description: "Ask ONE question at a time during brainstorming. Multiple choice preferred for clarity.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      question: z.string().min(1),
      type: z.enum(["multiple_choice", "open_ended", "yes_no", "priority_ranking"]).optional(),
      options: z.array(z.object({
        id: z.string(),
        label: z.string(),
        description: z.string().optional(),
        recommended: z.boolean().optional(),
      })).optional(),
      category: z.enum(["purpose", "constraints", "success_criteria", "approach", "tradeoffs"]).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      questionId: z.string(),
      formattedQuestion: z.string(),
      waitingForAnswer: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; question: string; type?: "multiple_choice" | "open_ended" | "yes_no" | "priority_ranking"; options?: any[]; category?: "purpose" | "constraints" | "success_criteria" | "approach" | "tradeoffs"; repoPath?: string }) => {
    const out = askBrainstormQuestion(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const answerBrainstormQuestionTool = [
  "answer_brainstorm_question",
  {
    title: "Answer Brainstorm Question",
    description: "Record the user's answer to a brainstorm question.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      questionId: z.string().min(1),
      answer: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      recorded: z.boolean(),
      questionsAnswered: z.number(),
      questionsTotal: z.number(),
      suggestNextQuestion: z.boolean(),
      nextQuestionSuggestion: z.any().optional(),
      readyForDesign: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; questionId: string; answer: string; repoPath?: string }) => {
    const out = answerBrainstormQuestion(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const proposeApproachesTool = [
  "propose_approaches",
  {
    title: "Propose Approaches",
    description: "Propose multiple implementation approaches with trade-offs (pros, cons, effort, risk).",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      approaches: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string(),
        pros: z.array(z.string()),
        cons: z.array(z.string()),
        recommended: z.boolean(),
        effort: z.enum(["low", "medium", "high"]),
        risk: z.enum(["low", "medium", "high"]),
      })),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      formatted: z.string(),
      waitingForSelection: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; approaches: any[]; repoPath?: string }) => {
    const out = proposeApproaches(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const presentDesignSectionTool = [
  "present_design_section",
  {
    title: "Present Design Section",
    description: "Present a design section (200-300 words max) for validation before proceeding.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      title: z.string().min(1),
      content: z.string().min(1),
      category: z.enum(["architecture", "components", "data_flow", "error_handling", "testing", "security", "performance"]),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      sectionId: z.string(),
      formatted: z.string(),
      wordCount: z.number(),
      waitingForValidation: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; title: string; content: string; category: "architecture" | "components" | "data_flow" | "error_handling" | "testing" | "security" | "performance"; repoPath?: string }) => {
    const out = presentDesignSection(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const validateDesignSectionTool = [
  "validate_design_section",
  {
    title: "Validate Design Section",
    description: "Record validation (approval or feedback) for a design section.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      sectionId: z.string().min(1),
      approved: z.boolean(),
      feedback: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      validated: z.boolean(),
      sectionsValidated: z.number(),
      sectionsTotal: z.number(),
      allSectionsValidated: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; sectionId: string; approved: boolean; feedback?: string; repoPath?: string }) => {
    const out = validateDesignSection(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const saveDesignDocumentTool = [
  "save_design_document",
  {
    title: "Save Design Document",
    description: "Save the final design document to docs/plans/ after all sections are validated.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      title: z.string().min(1),
      summary: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      documentPath: z.string(),
      content: z.string(),
    }).strict(),
  },
  (input: { sessionId: string; title: string; summary?: string; repoPath?: string }) => {
    const out = saveDesignDocument(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getBrainstormSessionTool = [
  "get_brainstorm_session",
  {
    title: "Get Brainstorm Session",
    description: "Get the current status of a brainstorm session.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { sessionId: string; repoPath?: string }) => {
    const out = getBrainstormSession(input);
    const result = out ?? { error: "Session not found" };
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

export const listBrainstormSessionsTool = [
  "list_brainstorm_sessions",
  {
    title: "List Brainstorm Sessions",
    description: "List all brainstorm sessions, optionally filtered by status.",
    inputSchema: z.object({
      status: z.enum(["gathering", "exploring", "designing", "validating", "completed"]).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      sessions: z.array(z.any()),
    }).strict(),
  },
  (input: { status?: "gathering" | "exploring" | "designing" | "validating" | "completed"; repoPath?: string }) => {
    const out = listBrainstormSessions(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: { sessions: out } };
  },
] as const;

// ============================================================================
// v0.6 Writing Plans Tools (superpowers-inspired TDD)
// ============================================================================

export const createImplementationPlanTool = [
  "create_implementation_plan",
  {
    title: "Create Implementation Plan",
    description: "Create a detailed implementation plan with bite-sized TDD tasks (2-5 min each).",
    inputSchema: z.object({
      name: z.string().min(1),
      goal: z.string().min(1),
      architecture: z.string().min(1),
      techStack: z.array(z.string()),
      designDocPath: z.string().optional(),
      createdBy: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { name: string; goal: string; architecture: string; techStack: string[]; designDocPath?: string; createdBy: string; repoPath?: string }) => {
    const out = createImplementationPlan(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const addPlanTaskTool = [
  "add_plan_task",
  {
    title: "Add Plan Task",
    description: "Add a task to an implementation plan with TDD steps.",
    inputSchema: z.object({
      planId: z.string().min(1),
      title: z.string().min(1),
      description: z.string().min(1),
      files: z.array(z.object({
        path: z.string(),
        action: z.enum(["create", "modify", "delete"]),
        lineRange: z.string().optional(),
        isTest: z.boolean().optional(),
      })),
      testCode: z.string().optional(),
      implementationCode: z.string().optional(),
      testCommand: z.string().optional(),
      commitMessage: z.string().optional(),
      dependsOn: z.array(z.string()).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { planId: string; title: string; description: string; files: any[]; testCode?: string; implementationCode?: string; testCommand?: string; commitMessage?: string; dependsOn?: string[]; repoPath?: string }) => {
    const out = addPlanTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getNextTaskTool = [
  "get_next_task",
  {
    title: "Get Next Task",
    description: "Get the next task to work on from the implementation plan.",
    inputSchema: z.object({
      planId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      task: z.any().nullable(),
      blockedBy: z.array(z.string()),
      allCompleted: z.boolean(),
    }).strict(),
  },
  (input: { planId: string; repoPath?: string }) => {
    const out = getNextTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const startPlanTaskTool = [
  "start_plan_task",
  {
    title: "Start Plan Task",
    description: "Mark a task as started and assign it to an agent.",
    inputSchema: z.object({
      planId: z.string().min(1),
      taskId: z.string().min(1),
      assignedTo: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { planId: string; taskId: string; assignedTo: string; repoPath?: string }) => {
    const out = startTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const completeStepTool = [
  "complete_step",
  {
    title: "Complete Step",
    description: "Mark a TDD step as completed within a task.",
    inputSchema: z.object({
      planId: z.string().min(1),
      taskId: z.string().min(1),
      stepNumber: z.number(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      step: z.any(),
      allStepsCompleted: z.boolean(),
      nextStep: z.any().nullable(),
    }).strict(),
  },
  (input: { planId: string; taskId: string; stepNumber: number; repoPath?: string }) => {
    const out = completeStep(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const completeTaskTool = [
  "complete_plan_task",
  {
    title: "Complete Plan Task",
    description: "Mark a task as completed after all steps are done.",
    inputSchema: z.object({
      planId: z.string().min(1),
      taskId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      task: z.any(),
      planCompleted: z.boolean(),
      nextTask: z.any().nullable(),
    }).strict(),
  },
  (input: { planId: string; taskId: string; repoPath?: string }) => {
    const out = completeTask(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const generateSubagentPromptTool = [
  "generate_subagent_prompt",
  {
    title: "Generate Subagent Prompt",
    description: "Generate a detailed prompt for a subagent to execute a task.",
    inputSchema: z.object({
      planId: z.string().min(1),
      taskId: z.string().min(1),
      contextFiles: z.array(z.string()).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.string(),
  },
  (input: { planId: string; taskId: string; contextFiles?: string[]; repoPath?: string }) => {
    const out = generateSubagentPrompt(input);
    return { content: [{ type: "text" as const, text: out }], structuredContent: { prompt: out } };
  },
] as const;

export const exportPlanAsMarkdownTool = [
  "export_plan_as_markdown",
  {
    title: "Export Plan as Markdown",
    description: "Export the implementation plan as a markdown document.",
    inputSchema: z.object({
      planId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      path: z.string(),
      content: z.string(),
    }).strict(),
  },
  (input: { planId: string; repoPath?: string }) => {
    const out = exportPlanAsMarkdown(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getPlanStatusTool = [
  "get_plan_status",
  {
    title: "Get Plan Status",
    description: "Get detailed status of an implementation plan.",
    inputSchema: z.object({
      planId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      plan: z.any(),
      tasksCompleted: z.number(),
      tasksTotal: z.number(),
      stepsCompleted: z.number(),
      stepsTotal: z.number(),
      percentComplete: z.number(),
      estimatedRemainingTasks: z.number(),
    }).strict(),
  },
  (input: { planId: string; repoPath?: string }) => {
    const out = getPlanStatus(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const listPlansTool = [
  "list_plans",
  {
    title: "List Plans",
    description: "List all implementation plans, optionally filtered by status.",
    inputSchema: z.object({
      status: z.enum(["draft", "ready", "in_progress", "completed", "blocked"]).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      plans: z.array(z.any()),
    }).strict(),
  },
  (input: { status?: "draft" | "ready" | "in_progress" | "completed" | "blocked"; repoPath?: string }) => {
    const out = listPlans(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: { plans: out } };
  },
] as const;

export const markPlanReadyTool = [
  "mark_plan_ready",
  {
    title: "Mark Plan Ready",
    description: "Mark an implementation plan as ready for execution.",
    inputSchema: z.object({
      planId: z.string().min(1),
      executionMode: z.enum(["manual", "subagent", "parallel"]).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { planId: string; executionMode?: "manual" | "subagent" | "parallel"; repoPath?: string }) => {
    const out = markPlanReady(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

// ============================================================================
// v0.6 Systematic Debugging Tools (4-phase methodology)
// ============================================================================

export const startDebugSessionTool = [
  "start_debug_session",
  {
    title: "Start Debug Session",
    description: "Start a systematic debugging session. Phase 1: Root Cause Investigation (NO FIXES YET!).",
    inputSchema: z.object({
      agentId: z.string().min(1),
      title: z.string().min(1),
      description: z.string().min(1),
      errorMessage: z.string().optional(),
      stackTrace: z.string().optional(),
      reproductionSteps: z.array(z.string()).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      session: z.any(),
      guidance: z.string(),
      nextActions: z.array(z.string()),
    }).strict(),
  },
  (input: { agentId: string; title: string; description: string; errorMessage?: string; stackTrace?: string; reproductionSteps?: string[]; repoPath?: string }) => {
    const out = startDebugSession(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const logInvestigationTool = [
  "log_investigation",
  {
    title: "Log Investigation",
    description: "Log investigation findings during Phase 1 (root cause analysis).",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      canReproduce: z.boolean().optional(),
      reproductionNotes: z.string().optional(),
      recentChanges: z.array(z.string()).optional(),
      errorAnalysis: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      session: z.any(),
      readyForPhase2: z.boolean(),
      missingItems: z.array(z.string()),
    }).strict(),
  },
  (input: { sessionId: string; canReproduce?: boolean; reproductionNotes?: string; recentChanges?: string[]; errorAnalysis?: string; repoPath?: string }) => {
    const out = logInvestigation(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const addEvidenceTool = [
  "add_evidence",
  {
    title: "Add Evidence",
    description: "Add evidence gathered during investigation (component inputs/outputs).",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      component: z.string().min(1),
      input: z.string().optional(),
      output: z.string().optional(),
      expected: z.string().optional(),
      notes: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { sessionId: string; component: string; input?: string; output?: string; expected?: string; notes?: string; repoPath?: string }) => {
    const out = addEvidence(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const completePhase1Tool = [
  "complete_phase_1",
  {
    title: "Complete Phase 1",
    description: "Complete Phase 1 (Investigation) and move to Phase 2 (Pattern Analysis). Requires error analysis and reproduction.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      success: z.boolean(),
      error: z.string().optional(),
      guidance: z.string(),
    }).strict(),
  },
  (input: { sessionId: string; repoPath?: string }) => {
    const out = completePhase1(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const logPatternsTool = [
  "log_patterns",
  {
    title: "Log Patterns",
    description: "Log patterns found during Phase 2 (working examples, reference implementations).",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      workingExamples: z.array(z.string()).optional(),
      referenceImplementations: z.array(z.string()).optional(),
      differences: z.array(z.string()).optional(),
      dependencies: z.array(z.string()).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      session: z.any(),
      readyForPhase3: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; workingExamples?: string[]; referenceImplementations?: string[]; differences?: string[]; dependencies?: string[]; repoPath?: string }) => {
    const out = logPatterns(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const completePhase2Tool = [
  "complete_phase_2",
  {
    title: "Complete Phase 2",
    description: "Complete Phase 2 (Pattern Analysis) and move to Phase 3 (Hypothesis Testing).",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      success: z.boolean(),
      guidance: z.string(),
    }).strict(),
  },
  (input: { sessionId: string; repoPath?: string }) => {
    const out = completePhase2(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const formHypothesisTool = [
  "form_hypothesis",
  {
    title: "Form Hypothesis",
    description: "Form a hypothesis about the root cause with a test plan.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      statement: z.string().min(1),
      reasoning: z.string().min(1),
      testPlan: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      hypothesis: z.any(),
      warning: z.string().optional(),
    }).strict(),
  },
  (input: { sessionId: string; statement: string; reasoning: string; testPlan: string; repoPath?: string }) => {
    const out = formHypothesis(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const testHypothesisTool = [
  "test_hypothesis",
  {
    title: "Test Hypothesis",
    description: "Record the result of testing a hypothesis.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      hypothesisId: z.string().min(1),
      result: z.enum(["confirmed", "rejected", "inconclusive"]),
      testNotes: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      hypothesis: z.any(),
      nextStep: z.string(),
      shouldEscalate: z.boolean(),
    }).strict(),
  },
  (input: { sessionId: string; hypothesisId: string; result: "confirmed" | "rejected" | "inconclusive"; testNotes?: string; repoPath?: string }) => {
    const out = testHypothesis(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const implementFixTool = [
  "implement_fix",
  {
    title: "Implement Fix",
    description: "Record the fix implementation in Phase 4. Only allowed after confirmed hypothesis!",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      testCase: z.string().min(1),
      fixDescription: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      session: z.any(),
      guidance: z.string(),
    }).strict(),
  },
  (input: { sessionId: string; testCase: string; fixDescription: string; repoPath?: string }) => {
    const out = implementFix(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const verifyFixTool = [
  "verify_fix",
  {
    title: "Verify Fix",
    description: "Verify that the fix resolves the issue and complete the debug session.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      testPassed: z.boolean(),
      noRegressions: z.boolean(),
      notes: z.string().optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      session: z.any(),
      resolved: z.boolean(),
      summary: z.string(),
    }).strict(),
  },
  (input: { sessionId: string; testPassed: boolean; noRegressions: boolean; notes?: string; repoPath?: string }) => {
    const out = verifyFix(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;

export const getDebugSessionTool = [
  "get_debug_session",
  {
    title: "Get Debug Session",
    description: "Get the current status of a debug session.",
    inputSchema: z.object({
      sessionId: z.string().min(1),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  (input: { sessionId: string; repoPath?: string }) => {
    const out = getDebugSession(input);
    const result = out ?? { error: "Session not found" };
    return { content: [{ type: "text" as const, text: JSON.stringify(result) }], structuredContent: result };
  },
] as const;

export const listDebugSessionsTool = [
  "list_debug_sessions",
  {
    title: "List Debug Sessions",
    description: "List all debug sessions, optionally filtered by status.",
    inputSchema: z.object({
      status: z.enum(["active", "resolved", "escalated", "abandoned"]).optional(),
      repoPath: z.string().optional(),
    }).strict(),
    outputSchema: z.object({
      sessions: z.array(z.any()),
    }).strict(),
  },
  (input: { status?: "active" | "resolved" | "escalated" | "abandoned"; repoPath?: string }) => {
    const out = listDebugSessions(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: { sessions: out } };
  },
] as const;

export const checkRedFlagsTool = [
  "check_red_flags",
  {
    title: "Check Red Flags",
    description: "Check for debugging anti-patterns (fixing without investigation, too many fix attempts).",
    inputSchema: z.object({
      thought: z.string().min(1),
    }).strict(),
    outputSchema: z.object({
      hasRedFlag: z.boolean(),
      matchedFlags: z.array(z.string()),
      guidance: z.string(),
    }).strict(),
  },
  (input: { thought: string }) => {
    const out = checkRedFlags(input);
    return { content: [{ type: "text" as const, text: JSON.stringify(out) }], structuredContent: out };
  },
] as const;
