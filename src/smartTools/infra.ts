/**
 * MCP Swarm v1.1.0 - Smart Tools: infra
 * Consolidated (17â†’7):
 *   swarm_health   = swarm_health + swarm_preemption
 *   swarm_external = swarm_external + swarm_platform
 *   swarm_expertise = swarm_expertise + swarm_routing
 *   swarm_knowledge = swarm_knowledge + swarm_docs + swarm_advice
 *   swarm_session  = swarm_session + swarm_timeline + swarm_screenshot
 *   swarm_clusters = swarm_clusters + swarm_conflict
 *   swarm_telegram = swarm_telegram + swarm_qa
 */

import { z } from "zod";

import { predictConflicts, analyzeConflictHistory, getConflictHotspots, recordConflictEvent } from "../workflows/conflictPrediction.js";
import { shareScreenshot, listScreenshots } from "../workflows/screenshot.js";
import { requestPlatformCheck, respondToPlatformCheck, getPendingPlatformChecks } from "../workflows/crossPlatform.js";
import { archiveFinding, searchKnowledge } from "../workflows/knowledgeBase.js";
import { triggerUrgentPreemption, resolveUrgent, getActiveUrgent } from "../workflows/preemption.js";
import { requestCollectiveAdvice, provideAdvice, getOpenAdviceRequests } from "../workflows/collectiveAdvice.js";
import { recordFileEdit, findBestAgent, getExpertiseMap, predictAffectedPaths, autoAssignTask } from "../workflows/smartRouting.js";
import { enableGitHubSync, enableLinearSync, syncFromGitHub, syncFromLinear, syncAll, exportTaskToGitHub, exportTaskToLinear, getSyncStatus, createGitHubIssue, closeGitHubIssue, addGitHubComment } from "../workflows/externalSync.js";
import { handleTelegramTool } from "../integrations/telegram.js";
import { autoGenerateDocs, generateTaskDocumentation, listDocumentation, getDocumentation } from "../workflows/autoDocumentation.js";
import { trackExpertise } from "../workflows/specialization.js";
import { recordAgentEdit, suggestAgentForTask as suggestAgentAdvanced, getTopExperts, listAllAgentExpertise } from "../workflows/smartRouting.js";
import { generateTimeline, getTimelineVisualization } from "../workflows/timeline.js";
import { checkAgentHealth, getDeadAgents, forceReassignTask, getSwarmHealthSummary } from "../workflows/agentHealth.js";
import { startSessionRecording, logSessionAction, stopSessionRecording, listSessionRecordings, replaySession } from "../workflows/sessionRecording.js";
import { startQALoop, runQAIteration, logQAFix, getQALoop, listQALoops, getQAFixSuggestions, generateQAReport } from "../workflows/qaLoop.js";
import { initToolClusters, listToolClusters, getClusterTools, findToolCluster, addToolToCluster, createToolCluster, getToolClusterSummary } from "../workflows/toolClusters.js";

// Helper to wrap results
function wrapResult(result: any) {
  return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }], structuredContent: result };
}

// ================================================================
// 1. swarm_health = swarm_health + swarm_preemption
// ================================================================
export const swarmHealthTool = [
  "swarm_health",
  {
    title: "Swarm Health",
    description: `Agent health monitoring & urgent task preemption.

Health Actions: check, dead, reassign, summary
Preemption Actions: preempt_trigger, preempt_resolve, preempt_active`,
    inputSchema: z.object({
      action: z.enum([
        // Health actions
        "check", "dead", "reassign", "summary",
        // Preemption actions
        "preempt_trigger", "preempt_resolve", "preempt_active"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for check)"),
      thresholdMinutes: z.number().optional().describe("Threshold minutes"),
      taskId: z.string().optional().describe("Task ID"),
      fromAgent: z.string().optional().describe("From agent (for reassign)"),
      toAgent: z.string().optional().describe("To agent (for reassign)"),
      reason: z.string().optional().describe("Reason"),
      // Preemption params
      title: z.string().optional().describe("Title (for preempt_trigger)"),
      initiator: z.string().optional().describe("Initiator (for preempt_trigger)"),
      affectedFiles: z.array(z.string()).optional().describe("Affected files (for preempt_trigger)"),
      urgentId: z.string().optional().describe("Urgent ID (for preempt_resolve)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "check":
        return wrapResult(await checkAgentHealth({ repoPath: input.repoPath, agent: input.agent, thresholdMinutes: input.thresholdMinutes }));
      case "dead":
        return wrapResult(await getDeadAgents({ repoPath: input.repoPath, thresholdMinutes: input.thresholdMinutes }));
      case "reassign":
        return wrapResult(await forceReassignTask({ repoPath: input.repoPath, taskId: input.taskId, fromAgent: input.fromAgent, toAgent: input.toAgent, reason: input.reason, commitMode: input.commitMode || "push" }));
      case "summary":
        return wrapResult(await getSwarmHealthSummary({ repoPath: input.repoPath, thresholdMinutes: input.thresholdMinutes }));
      case "preempt_trigger":
        return wrapResult(await triggerUrgentPreemption({ repoPath: input.repoPath, taskId: input.taskId, title: input.title, reason: input.reason, initiator: input.initiator, affectedFiles: input.affectedFiles || [], commitMode: input.commitMode || "push" }));
      case "preempt_resolve":
        return wrapResult(await resolveUrgent({ repoPath: input.repoPath, urgentId: input.urgentId, commitMode: input.commitMode || "push" }));
      case "preempt_active":
        return wrapResult(await getActiveUrgent(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ================================================================
// 2. swarm_external = swarm_external + swarm_platform
// ================================================================
export const swarmExternalTool = [
  "swarm_external",
  {
    title: "Swarm External",
    description: `GitHub/Linear sync & cross-platform checks.

Sync Actions: enable_github, enable_linear, sync_github, sync_linear, sync_all, export_github, export_linear, status, create_issue, close_issue, comment
Platform Actions: platform_request, platform_respond, platform_list`,
    inputSchema: z.object({
      action: z.enum([
        // Sync actions
        "enable_github", "enable_linear", "sync_github", "sync_linear", "sync_all",
        "export_github", "export_linear", "status", "create_issue", "close_issue", "comment",
        // Platform actions
        "platform_request", "platform_respond", "platform_list"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // GitHub
      owner: z.string().optional().describe("GitHub owner"),
      repo: z.string().optional().describe("GitHub repo"),
      labelFilter: z.array(z.string()).optional().describe("Label filter"),
      autoImport: z.boolean().optional().describe("Auto import issues"),
      autoClose: z.boolean().optional().describe("Auto close on done"),
      // Linear
      teamId: z.string().optional().describe("Linear team ID"),
      projectId: z.string().optional().describe("Linear project ID"),
      // Export/Issues
      taskId: z.string().optional().describe("Task ID (for export)"),
      issueNumber: z.string().optional().describe("Issue number"),
      title: z.string().optional().describe("Issue title"),
      body: z.string().optional().describe("Issue body"),
      labels: z.array(z.string()).optional().describe("Labels"),
      // Platform params
      fromAgent: z.string().optional().describe("From agent (for platform_request)"),
      targetPlatforms: z.array(z.string()).optional().describe("Target platforms"),
      component: z.string().optional().describe("Component"),
      description: z.string().optional().describe("Description"),
      screenshotBase64: z.string().optional().describe("Screenshot base64"),
      checkId: z.string().optional().describe("Check ID (for platform_respond)"),
      agent: z.string().optional().describe("Agent (for platform_respond)"),
      result: z.enum(["pass", "fail"]).optional().describe("Result (for platform_respond)"),
      issueDescription: z.string().optional().describe("Issue description (for platform_respond)"),
      comment: z.string().optional().describe("Comment text"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    switch (input.action) {
      // Sync actions
      case "enable_github":
        return wrapResult(await enableGitHubSync(repoPath, input.owner, input.repo, { labelFilter: input.labelFilter, autoImport: input.autoImport, autoClose: input.autoClose }));
      case "enable_linear":
        return wrapResult(await enableLinearSync(repoPath, input.teamId, { projectId: input.projectId, autoImport: input.autoImport, autoClose: input.autoClose }));
      case "sync_github":
        return wrapResult(await syncFromGitHub(repoPath));
      case "sync_linear":
        return wrapResult(await syncFromLinear(repoPath));
      case "sync_all":
        return wrapResult(await syncAll(repoPath));
      case "export_github":
        return wrapResult(await exportTaskToGitHub(repoPath, input.taskId));
      case "export_linear":
        return wrapResult(await exportTaskToLinear(repoPath, input.taskId));
      case "status":
        return wrapResult(await getSyncStatus(repoPath));
      case "create_issue":
        return wrapResult(await createGitHubIssue(repoPath, input.title, input.body, input.labels));
      case "close_issue":
        return wrapResult(await closeGitHubIssue(repoPath, input.issueNumber, input.comment));
      case "comment":
        return wrapResult(await addGitHubComment(repoPath, input.issueNumber, input.comment));
      // Platform actions
      case "platform_request":
        return wrapResult(await requestPlatformCheck({ repoPath, fromAgent: input.fromAgent, targetPlatforms: input.targetPlatforms, component: input.component, description: input.description, screenshotBase64: input.screenshotBase64, commitMode: input.commitMode || "push" }));
      case "platform_respond":
        return wrapResult(await respondToPlatformCheck({ repoPath, checkId: input.checkId, agent: input.agent, result: input.result, issueDescription: input.issueDescription, screenshotBase64: input.screenshotBase64, commitMode: input.commitMode || "push" }));
      case "platform_list":
        return wrapResult(await getPendingPlatformChecks(repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ================================================================
// 3. swarm_expertise = swarm_expertise + swarm_routing
// ================================================================
export const swarmExpertiseTool = [
  "swarm_expertise",
  {
    title: "Swarm Expertise",
    description: `Agent expertise tracking & smart task routing.

Expertise Actions: track, suggest, record, experts, list
Routing Actions: route_record, route_find_agent, route_expertise, route_predict, route_auto_assign`,
    inputSchema: z.object({
      action: z.enum([
        // Expertise actions
        "track", "suggest", "record", "experts", "list",
        // Routing actions
        "route_record", "route_find_agent", "route_expertise", "route_predict", "route_auto_assign"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      agentId: z.string().optional().describe("Agent ID"),
      filesEdited: z.array(z.string()).optional().describe("Files edited"),
      files: z.array(z.string()).optional().describe("Files"),
      taskDescription: z.string().optional().describe("Task description"),
      filesLikelyInvolved: z.array(z.string()).optional().describe("Files likely involved"),
      directories: z.array(z.string()).optional().describe("Directories"),
      keywords: z.array(z.string()).optional().describe("Keywords"),
      taskKeywords: z.array(z.string()).optional().describe("Task keywords"),
      area: z.string().optional().describe("Area (for experts)"),
      limit: z.number().optional().describe("Limit"),
      // Routing params
      filePath: z.string().optional().describe("File path (for route_record)"),
      filePaths: z.array(z.string()).optional().describe("File paths (for route_find_agent)"),
      excludeBusy: z.boolean().optional().describe("Exclude busy agents"),
      taskId: z.string().optional().describe("Task ID (for route_auto_assign)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      // Expertise actions
      case "track":
        return wrapResult(await trackExpertise({ repoPath: input.repoPath, agent: input.agent, filesEdited: input.filesEdited || [], commitMode: input.commitMode || "push" }));
      case "suggest":
        return wrapResult(await suggestAgentAdvanced({ repoPath: input.repoPath, taskDescription: input.taskDescription || "", files: input.files, directories: input.directories, keywords: input.keywords }));
      case "record":
        return wrapResult(await recordAgentEdit({ repoPath: input.repoPath, agent: input.agent, filesEdited: input.files || input.filesEdited || [], taskKeywords: input.taskKeywords || input.keywords }));
      case "experts":
        return wrapResult(await getTopExperts({ repoPath: input.repoPath, area: input.area, limit: input.limit }));
      case "list":
        return wrapResult(await listAllAgentExpertise({ repoPath: input.repoPath }));
      // Routing actions
      case "route_record":
        return wrapResult(await recordFileEdit({ repoPath: input.repoPath, agentName: input.agentId, filePath: input.filePath }));
      case "route_find_agent":
        return wrapResult(await findBestAgent({ repoPath: input.repoPath, affectedPaths: input.filePaths || [], excludeAgents: input.excludeBusy ? [] : undefined }));
      case "route_expertise":
        return wrapResult(await getExpertiseMap({ repoPath: input.repoPath }));
      case "route_predict":
        return wrapResult(predictAffectedPaths(input.taskDescription || ""));
      case "route_auto_assign":
        return wrapResult(await autoAssignTask({ repoPath: input.repoPath, taskId: input.taskId, taskTitle: input.taskDescription || "", taskDescription: input.taskDescription || "", availableAgents: [] }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ================================================================
// 4. swarm_knowledge = swarm_knowledge + swarm_docs + swarm_advice
// ================================================================
export const swarmKnowledgeTool = [
  "swarm_knowledge",
  {
    title: "Swarm Knowledge",
    description: `Knowledge base, auto-documentation & collective advice.

Knowledge Actions: archive, search
Docs Actions: docs_generate, docs_task, docs_list, docs_get
Advice Actions: advice_request, advice_provide, advice_list`,
    inputSchema: z.object({
      action: z.enum([
        // Knowledge actions
        "archive", "search",
        // Docs actions
        "docs_generate", "docs_task", "docs_list", "docs_get",
        // Advice actions
        "advice_request", "advice_provide", "advice_list"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      category: z.enum(["bug", "workaround", "pattern", "config", "dependency", "architecture", "other"]).optional().describe("Category"),
      title: z.string().optional().describe("Title"),
      description: z.string().optional().describe("Description"),
      solution: z.string().optional().describe("Solution (for archive)"),
      relatedFiles: z.array(z.string()).optional().describe("Related files"),
      tags: z.array(z.string()).optional().describe("Tags"),
      query: z.string().optional().describe("Search query"),
      // Docs params
      taskId: z.string().optional().describe("Task ID"),
      feature: z.string().optional().describe("Feature name"),
      usage: z.string().optional().describe("Usage"),
      taskTitle: z.string().optional().describe("Task title"),
      filesModified: z.array(z.string()).optional().describe("Files modified"),
      summary: z.string().optional().describe("Summary"),
      // Advice params
      problem: z.string().optional().describe("Problem"),
      context: z.string().optional().describe("Context"),
      codeSnippet: z.string().optional().describe("Code snippet"),
      filesInvolved: z.array(z.string()).optional().describe("Files involved"),
      attemptedSolutions: z.array(z.string()).optional().describe("Attempted solutions"),
      requestId: z.string().optional().describe("Request ID (for advice_provide)"),
      suggestion: z.string().optional().describe("Suggestion (for advice_provide)"),
      confidence: z.enum(["low", "medium", "high"]).optional().describe("Confidence"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    switch (input.action) {
      // Knowledge actions
      case "archive":
        return wrapResult(await archiveFinding({ repoPath, agent: input.agent, category: input.category || "other", title: input.title, description: input.description, solution: input.solution, relatedFiles: input.relatedFiles, tags: input.tags, commitMode: input.commitMode || "push" }));
      case "search":
        return wrapResult(await searchKnowledge({ repoPath, query: input.query, category: input.category, tags: input.tags }));
      // Docs actions
      case "docs_generate":
        return wrapResult(await autoGenerateDocs({ repoPath, agent: input.agent, taskId: input.taskId, feature: input.feature, description: input.description, usage: input.usage, commitMode: input.commitMode || "push" }));
      case "docs_task":
        return wrapResult(await generateTaskDocumentation({ repoPath, taskId: input.taskId, taskTitle: input.taskTitle, agent: input.agent, filesModified: input.filesModified || [], summary: input.summary, commitMode: input.commitMode || "push" }));
      case "docs_list":
        return wrapResult(await listDocumentation(repoPath));
      case "docs_get":
        return wrapResult(await getDocumentation({ repoPath, taskId: input.taskId }));
      // Advice actions
      case "advice_request":
        return wrapResult(await requestCollectiveAdvice({ repoPath, agent: input.agent, taskId: input.taskId, problem: input.problem, context: input.context, codeSnippet: input.codeSnippet, filesInvolved: input.filesInvolved || [], attemptedSolutions: input.attemptedSolutions || [], commitMode: input.commitMode || "push" }));
      case "advice_provide":
        return wrapResult(await provideAdvice({ repoPath, requestId: input.requestId, agent: input.agent, suggestion: input.suggestion, confidence: input.confidence, commitMode: input.commitMode || "push" }));
      case "advice_list":
        return wrapResult(await getOpenAdviceRequests(repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ================================================================
// 5. swarm_session = swarm_session + swarm_timeline + swarm_screenshot
// ================================================================
export const swarmSessionTool = [
  "swarm_session",
  {
    title: "Swarm Session",
    description: `Session recording, event timeline & screenshot sharing.

Session Actions: start, log, stop, list, replay
Timeline Actions: timeline_generate, timeline_visualize
Screenshot Actions: screenshot_share, screenshot_list`,
    inputSchema: z.object({
      action: z.enum([
        // Session actions
        "start", "log", "stop", "list", "replay",
        // Timeline actions
        "timeline_generate", "timeline_visualize",
        // Screenshot actions
        "screenshot_share", "screenshot_list"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      taskId: z.string().optional().describe("Task ID (for start)"),
      sessionId: z.string().optional().describe("Session ID"),
      actionType: z.string().optional().describe("Action type (for log)"),
      tool: z.string().optional().describe("Tool (for log)"),
      file: z.string().optional().describe("File (for log)"),
      inputData: z.any().optional().describe("Input data (for log)"),
      outputData: z.any().optional().describe("Output data (for log)"),
      duration: z.number().optional().describe("Duration ms (for log)"),
      error: z.string().optional().describe("Error (for log)"),
      summary: z.string().optional().describe("Summary (for stop)"),
      limit: z.number().optional().describe("Limit"),
      fromIndex: z.number().optional().describe("From index (for replay)"),
      toIndex: z.number().optional().describe("To index (for replay)"),
      // Timeline params
      since: z.string().optional().describe("Since timestamp (for timeline_generate)"),
      // Screenshot params
      imageBase64: z.string().optional().describe("Image base64 (for screenshot_share)"),
      description: z.string().optional().describe("Description (for screenshot_share)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      // Session actions
      case "start":
        return wrapResult(await startSessionRecording({ repoPath: input.repoPath, agent: input.agent, taskId: input.taskId }));
      case "log":
        return wrapResult(await logSessionAction({ repoPath: input.repoPath, sessionId: input.sessionId, actionType: input.actionType, tool: input.tool, file: input.file, inputData: input.inputData, outputData: input.outputData, duration: input.duration, error: input.error }));
      case "stop":
        return wrapResult(await stopSessionRecording({ repoPath: input.repoPath, sessionId: input.sessionId, summary: input.summary }));
      case "list":
        return wrapResult(await listSessionRecordings({ repoPath: input.repoPath, agent: input.agent, limit: input.limit }));
      case "replay":
        return wrapResult(await replaySession({ repoPath: input.repoPath, sessionId: input.sessionId, fromIndex: input.fromIndex, toIndex: input.toIndex }));
      // Timeline actions
      case "timeline_generate":
        return wrapResult(await generateTimeline({ repoPath: input.repoPath, since: input.since, limit: input.limit }));
      case "timeline_visualize":
        return wrapResult(await getTimelineVisualization(input.repoPath));
      // Screenshot actions
      case "screenshot_share":
        return wrapResult(await shareScreenshot({ repoPath: input.repoPath, agent: input.agent, imageBase64: input.imageBase64, description: input.description, commitMode: input.commitMode || "push" }));
      case "screenshot_list":
        return wrapResult(await listScreenshots(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ================================================================
// 6. swarm_clusters = swarm_clusters + swarm_conflict
// ================================================================
export const swarmClustersTool = [
  "swarm_clusters",
  {
    title: "Swarm Clusters",
    description: `Tool clusters & conflict prediction.

Cluster Actions: init, list, tools, find, add, create, summary
Conflict Actions: conflict_predict, conflict_analyze, conflict_hotspots, conflict_record`,
    inputSchema: z.object({
      action: z.enum([
        // Cluster actions
        "init", "list", "tools", "find", "add", "create", "summary",
        // Conflict actions
        "conflict_predict", "conflict_analyze", "conflict_hotspots", "conflict_record"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      clusterId: z.string().optional().describe("Cluster ID"),
      toolName: z.string().optional().describe("Tool name"),
      id: z.string().optional().describe("ID (for create)"),
      name: z.string().optional().describe("Name (for create)"),
      description: z.string().optional().describe("Description (for create)"),
      icon: z.string().optional().describe("Icon (for create)"),
      toolsList: z.array(z.string()).optional().describe("Tools (for create)"),
      // Conflict params
      filesToEdit: z.array(z.string()).optional().describe("Files to edit (for conflict_predict)"),
      file: z.string().optional().describe("File (for conflict_record)"),
      agent: z.string().optional().describe("Agent (for conflict_record)"),
      resolved: z.boolean().optional().describe("Resolved (for conflict_record)"),
      lookbackDays: z.number().optional().describe("Lookback days (for conflict_analyze)"),
      limit: z.number().optional().describe("Limit (for conflict_hotspots)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      // Cluster actions
      case "init":
        return wrapResult(await initToolClusters({ repoPath: input.repoPath, commitMode: input.commitMode || "push" }));
      case "list":
        return wrapResult(await listToolClusters({ repoPath: input.repoPath }));
      case "tools":
        return wrapResult(await getClusterTools({ repoPath: input.repoPath, clusterId: input.clusterId }));
      case "find":
        return wrapResult(await findToolCluster({ repoPath: input.repoPath, toolName: input.toolName }));
      case "add":
        return wrapResult(await addToolToCluster({ repoPath: input.repoPath, clusterId: input.clusterId, toolName: input.toolName, commitMode: input.commitMode || "push" }));
      case "create":
        return wrapResult(await createToolCluster({ repoPath: input.repoPath, id: input.id, name: input.name, description: input.description, icon: input.icon, tools: input.toolsList, commitMode: input.commitMode || "push" }));
      case "summary":
        return wrapResult(await getToolClusterSummary({ repoPath: input.repoPath }));
      // Conflict actions
      case "conflict_predict":
        return wrapResult(await predictConflicts({ repoPath: input.repoPath, filesToEdit: input.filesToEdit || [] }));
      case "conflict_analyze":
        return wrapResult(await analyzeConflictHistory({ repoPath: input.repoPath, lookbackDays: input.lookbackDays, commitMode: input.commitMode || "push" }));
      case "conflict_hotspots":
        return wrapResult(await getConflictHotspots({ repoPath: input.repoPath, limit: input.limit }));
      case "conflict_record":
        return wrapResult(await recordConflictEvent({ repoPath: input.repoPath, file: input.file, agent: input.agent, resolved: input.resolved ?? false, commitMode: input.commitMode || "push" }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ================================================================
// 7. swarm_telegram = swarm_telegram + swarm_qa
// ================================================================
export const swarmTelegramTool = [
  "swarm_telegram",
  {
    title: "Swarm Telegram",
    description: `Telegram Bot integration & QA loop management.

Telegram Actions: setup, config, enable, disable, send, notify_task_created, notify_task_completed, notify_task_failed, notify_agent_joined, notify_agent_died, start_polling, stop_polling, command
QA Actions: qa_start, qa_iterate, qa_fix, qa_get, qa_list, qa_suggest, qa_report`,
    inputSchema: z.object({
      action: z.enum([
        // Telegram actions
        "setup", "config", "enable", "disable", "send",
        "notify_task_created", "notify_task_completed", "notify_task_failed",
        "notify_agent_joined", "notify_agent_died",
        "start_polling", "stop_polling", "command",
        // QA actions
        "qa_start", "qa_iterate", "qa_fix", "qa_get", "qa_list", "qa_suggest", "qa_report"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // Telegram params
      botToken: z.string().optional().describe("Telegram Bot Token"),
      chatId: z.string().optional().describe("Chat ID for notifications"),
      enabled: z.boolean().optional().describe("Enable/disable bot"),
      taskId: z.string().optional().describe("Task ID"),
      title: z.string().optional().describe("Task title"),
      priority: z.string().optional().describe("Task priority"),
      agent: z.string().optional().describe("Agent name"),
      message: z.string().optional().describe("Message text"),
      command: z.string().optional().describe("Bot command"),
      args: z.array(z.string()).optional().describe("Command arguments"),
      // QA params
      branch: z.string().optional().describe("Branch (for qa_start)"),
      maxIterations: z.number().optional().describe("Max iterations (for qa_start)"),
      autoFix: z.boolean().optional().describe("Auto fix (for qa_start)"),
      checks: z.array(z.string()).optional().describe("Checks (for qa_start)"),
      loopId: z.string().optional().describe("Loop ID"),
      checkResults: z.any().optional().describe("Check results (for qa_iterate)"),
      fixDescription: z.string().optional().describe("Fix description (for qa_fix)"),
      status: z.string().optional().describe("Status filter (for qa_list)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    switch (input.action) {
      // Telegram actions
      case "setup":
      case "config":
      case "enable":
      case "disable":
      case "send":
      case "notify_task_created":
      case "notify_task_completed":
      case "notify_task_failed":
      case "notify_agent_joined":
      case "notify_agent_died":
      case "start_polling":
      case "stop_polling":
      case "command":
        return wrapResult(await handleTelegramTool({ ...input, repoPath }));
      // QA actions
      case "qa_start":
        return wrapResult(await startQALoop({ repoPath, taskId: input.taskId, branch: input.branch, maxIterations: input.maxIterations, autoFix: input.autoFix, checks: input.checks, commitMode: input.commitMode || "push" }));
      case "qa_iterate":
        return wrapResult(await runQAIteration({ repoPath, loopId: input.loopId, checkResults: input.checkResults, commitMode: input.commitMode || "push" }));
      case "qa_fix":
        return wrapResult(await logQAFix({ repoPath, loopId: input.loopId, fixDescription: input.fixDescription, commitMode: input.commitMode || "push" }));
      case "qa_get":
        return wrapResult(await getQALoop({ repoPath, loopId: input.loopId }));
      case "qa_list":
        return wrapResult(await listQALoops({ repoPath, status: input.status }));
      case "qa_suggest":
        return wrapResult(await getQAFixSuggestions({ repoPath, loopId: input.loopId }));
      case "qa_report":
        return wrapResult(await generateQAReport({ repoPath, loopId: input.loopId, commitMode: input.commitMode || "push" }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;
