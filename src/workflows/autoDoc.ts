import fs from "node:fs/promises";
import path from "node:path";

import { git, gitTry, normalizeLineEndings } from "./git.js";
import { getRepoRoot } from "./repo.js";

export type DocEntry = {
  id: string;
  agent: string;
  taskId: string;
  feature: string;
  description: string;
  usage?: string;
  filesChanged: string[];
  createdAt: number;
};

async function safePush(repoRoot: string): Promise<void> {
  try {
    await git(["push"], { cwd: repoRoot });
  } catch {
    await git(["push", "-u", "origin", "HEAD"], { cwd: repoRoot });
  }
}

async function ensureDocsDir(repoRoot: string): Promise<string> {
  const dir = path.join(repoRoot, "orchestrator", "docs");
  await fs.mkdir(dir, { recursive: true });
  return dir;
}

export async function autoGenerateDocs(input: {
  repoPath?: string;
  agent: string;
  taskId: string;
  feature: string;
  description: string;
  usage?: string;
  commitMode: "none" | "local" | "push";
}): Promise<{ docId: string; docPath: string }> {
  const repoRoot = await getRepoRoot(input.repoPath);
  const docsDir = await ensureDocsDir(repoRoot);

  // Get files changed in current branch compared to main
  const diffRes = await gitTry(["diff", "--name-only", "main...HEAD"], { cwd: repoRoot });
  const filesChanged = normalizeLineEndings(diffRes.stdout).trim().split("\n").filter(Boolean);

  const docId = `doc-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const doc: DocEntry = {
    id: docId,
    agent: input.agent,
    taskId: input.taskId,
    feature: input.feature,
    description: input.description,
    usage: input.usage,
    filesChanged,
    createdAt: Date.now(),
  };

  // Save JSON
  const jsonPath = path.join(docsDir, `${docId}.json`);
  await fs.writeFile(jsonPath, JSON.stringify(doc, null, 2) + "\n", "utf8");

  // Generate markdown doc
  const mdPath = path.join(docsDir, `${input.feature.toLowerCase().replace(/\s+/g, "-")}.md`);
  const mdContent = `# ${input.feature}

**Task ID:** ${input.taskId}
**Author:** ${input.agent}
**Date:** ${new Date(doc.createdAt).toISOString()}

## Description

${input.description}

${input.usage ? `## Usage\n\n${input.usage}` : ""}

## Files Changed

${filesChanged.map(f => `- \`${f}\``).join("\n")}

---
*Auto-generated documentation by MCP Orchestrator*
`;

  await fs.writeFile(mdPath, mdContent, "utf8");

  // Update docs index
  await updateDocsIndex(repoRoot);

  const relJson = path.posix.join("orchestrator", "docs", `${docId}.json`);
  const relMd = path.posix.join("orchestrator", "docs", `${input.feature.toLowerCase().replace(/\s+/g, "-")}.md`);
  const relIndex = path.posix.join("orchestrator", "docs", "INDEX.md");

  if (input.commitMode !== "none") {
    await git(["add", relJson, relMd, relIndex], { cwd: repoRoot });
    await git(["commit", "-m", `ðŸ“š Docs: ${input.feature} by ${input.agent}`], { cwd: repoRoot });
    if (input.commitMode === "push") await safePush(repoRoot);
  }

  return { docId, docPath: mdPath };
}

async function updateDocsIndex(repoRoot: string): Promise<void> {
  const docsDir = path.join(repoRoot, "orchestrator", "docs");
  const docs: DocEntry[] = [];

  try {
    const entries = await fs.readdir(docsDir, { withFileTypes: true });
    for (const ent of entries) {
      if (!ent.isFile() || !ent.name.endsWith(".json")) continue;
      try {
        const raw = await fs.readFile(path.join(docsDir, ent.name), "utf8");
        docs.push(JSON.parse(raw));
      } catch {
        // ignore
      }
    }
  } catch {
    // dir doesn't exist
  }

  docs.sort((a, b) => b.createdAt - a.createdAt);

  const indexContent = `# ðŸ“š Documentation Index

**Total Documents:** ${docs.length}
**Last Update:** ${new Date().toISOString()}

## Features

${docs.map(d => `- [${d.feature}](./${d.feature.toLowerCase().replace(/\s+/g, "-")}.md) - ${d.description.slice(0, 100)}...`).join("\n")}

## By Task

${[...new Set(docs.map(d => d.taskId))].map(taskId => {
  const taskDocs = docs.filter(d => d.taskId === taskId);
  return `### ${taskId}\n${taskDocs.map(d => `- ${d.feature}`).join("\n")}`;
}).join("\n\n")}
`;

  await fs.writeFile(path.join(docsDir, "INDEX.md"), indexContent, "utf8");
}

export async function listDocs(repoPath?: string): Promise<DocEntry[]> {
  const repoRoot = await getRepoRoot(repoPath);
  const docsDir = path.join(repoRoot, "orchestrator", "docs");
  const docs: DocEntry[] = [];

  try {
    const entries = await fs.readdir(docsDir, { withFileTypes: true });
    for (const ent of entries) {
      if (!ent.isFile() || !ent.name.endsWith(".json")) continue;
      try {
        const raw = await fs.readFile(path.join(docsDir, ent.name), "utf8");
        docs.push(JSON.parse(raw));
      } catch {
        // ignore
      }
    }
  } catch {
    // dir doesn't exist
  }

  docs.sort((a, b) => b.createdAt - a.createdAt);
  return docs;
}
