/**
 * Auto-Documentation Workflow
 * 
 * Автоматически генерирует документацию когда агент завершает фичу.
 * Документация сохраняется в swarm/docs/
 */

import { execSync } from "child_process";
import * as fs from "fs";
import * as path from "path";
import { getRepoRoot } from "./repo.js";

type DocGenerationInput = {
  repoPath?: string;
  taskId: string;
  taskTitle: string;
  agent: string;
  filesModified: string[];
  summary?: string;
  commitMode: "none" | "local" | "push";
};

type DocGenerationOutput = {
  docPath: string;
  indexUpdated: boolean;
};

type DocEntry = {
  id: string;
  taskId: string;
  title: string;
  agent: string;
  createdAt: string;
  filesModified: string[];
  summary: string;
};

/**
 * Генерирует документацию после завершения задачи
 */
export async function generateTaskDocumentation(input: DocGenerationInput): Promise<DocGenerationOutput> {
  const repoRoot = await getRepoRoot(input.repoPath);
  const docsDir = path.join(repoRoot, "swarm", "docs");
  
  // Создаем папку docs если не существует
  fs.mkdirSync(docsDir, { recursive: true });
  
  const timestamp = new Date().toISOString();
  const docId = `doc-${input.taskId}-${Date.now()}`;
  const docFilename = `${input.taskId}.md`;
  const docPath = path.join(docsDir, docFilename);
  
  // Получаем diff для измененных файлов
  const fileDiffs = await getFileDiffs(repoRoot, input.filesModified);
  
  // Генерируем автоматический summary если не передан
  const summary = input.summary || await generateAutoSummary(repoRoot, input.filesModified);
  
  // Создаем документ
  const docContent = `# ${input.taskTitle}

**Task ID:** ${input.taskId}
**Author:** ${input.agent}
**Created:** ${timestamp}
**Files Modified:** ${input.filesModified.length}

## Summary

${summary}

## Files Changed

${input.filesModified.map(f => `- \`${f}\``).join("\n")}

## Changes Detail

${fileDiffs}

---
*Auto-generated by MCP Swarm Orchestrator*
`;
  
  fs.writeFileSync(docPath, docContent, "utf-8");
  
  // Обновляем индекс документации
  const indexUpdated = await updateDocsIndex(repoRoot, {
    id: docId,
    taskId: input.taskId,
    title: input.taskTitle,
    agent: input.agent,
    createdAt: timestamp,
    filesModified: input.filesModified,
    summary: summary.slice(0, 200) + (summary.length > 200 ? "..." : ""),
  });
  
  // Commit если нужно
  if (input.commitMode !== "none") {
    const msg = `docs: auto-generate documentation for ${input.taskId}`;
    try {
      execSync(`git add "${docsDir}"`, { cwd: repoRoot, stdio: "pipe" });
      execSync(`git commit -m "${msg}"`, { cwd: repoRoot, stdio: "pipe" });
      if (input.commitMode === "push") {
        execSync(`git push`, { cwd: repoRoot, stdio: "pipe" });
      }
    } catch { /* ignore if nothing to commit */ }
  }
  
  return { docPath, indexUpdated };
}

/**
 * Получает diff для списка файлов
 */
async function getFileDiffs(repoRoot: string, files: string[]): Promise<string> {
  const diffs: string[] = [];
  
  for (const file of files.slice(0, 10)) { // Ограничиваем 10 файлами
    try {
      const diff = execSync(`git diff HEAD~1 -- "${file}"`, { 
        cwd: repoRoot, 
        encoding: "utf-8",
        maxBuffer: 1024 * 1024 
      });
      if (diff.trim()) {
        diffs.push(`### ${file}\n\n\`\`\`diff\n${diff.slice(0, 2000)}\n\`\`\`\n`);
      }
    } catch {
      // Файл новый или удален
      diffs.push(`### ${file}\n\n*(new or deleted file)*\n`);
    }
  }
  
  if (files.length > 10) {
    diffs.push(`\n*...and ${files.length - 10} more files*\n`);
  }
  
  return diffs.join("\n") || "*No diff available*";
}

/**
 * Генерирует автоматический summary на основе измененных файлов
 */
async function generateAutoSummary(repoRoot: string, files: string[]): Promise<string> {
  const extensions = new Map<string, number>();
  const directories = new Map<string, number>();
  
  for (const file of files) {
    const ext = path.extname(file) || "(no ext)";
    const dir = path.dirname(file);
    extensions.set(ext, (extensions.get(ext) || 0) + 1);
    directories.set(dir, (directories.get(dir) || 0) + 1);
  }
  
  const topExtensions = [...extensions.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([ext, count]) => `${ext} (${count})`)
    .join(", ");
  
  const topDirs = [...directories.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([dir, count]) => `${dir} (${count})`)
    .join(", ");
  
  return `Modified ${files.length} files. Main file types: ${topExtensions}. Main directories: ${topDirs}.`;
}

/**
 * Обновляет индекс документации (DOCS_INDEX.md)
 */
async function updateDocsIndex(repoRoot: string, entry: DocEntry): Promise<boolean> {
  const indexPath = path.join(repoRoot, "swarm", "docs", "INDEX.md");
  
  let content = "# Documentation Index\n\n| Task | Title | Author | Date | Files |\n|------|-------|--------|------|-------|\n";
  
  if (fs.existsSync(indexPath)) {
    const existing = fs.readFileSync(indexPath, "utf-8");
    // Извлекаем существующие строки таблицы
    const lines = existing.split("\n").filter(l => l.startsWith("|") && !l.includes("Task") && !l.includes("---"));
    content = "# Documentation Index\n\n| Task | Title | Author | Date | Files |\n|------|-------|--------|------|-------|\n";
    content += lines.join("\n") + "\n";
  }
  
  const date = entry.createdAt.split("T")[0];
  content += `| [${entry.taskId}](./${entry.taskId}.md) | ${entry.title.slice(0, 40)} | ${entry.agent} | ${date} | ${entry.filesModified.length} |\n`;
  
  fs.writeFileSync(indexPath, content, "utf-8");
  return true;
}

/**
 * Получает список всех документов
 */
export async function listDocumentation(repoPath?: string): Promise<{ docs: DocEntry[] }> {
  const repoRoot = await getRepoRoot(repoPath);
  const docsDir = path.join(repoRoot, "swarm", "docs");
  
  if (!fs.existsSync(docsDir)) {
    return { docs: [] };
  }
  
  const files = fs.readdirSync(docsDir).filter(f => f.endsWith(".md") && f !== "INDEX.md");
  const docs: DocEntry[] = [];
  
  for (const file of files) {
    const content = fs.readFileSync(path.join(docsDir, file), "utf-8");
    const taskIdMatch = content.match(/\*\*Task ID:\*\* (.+)/);
    const authorMatch = content.match(/\*\*Author:\*\* (.+)/);
    const createdMatch = content.match(/\*\*Created:\*\* (.+)/);
    const titleMatch = content.match(/^# (.+)/m);
    
    if (taskIdMatch) {
      docs.push({
        id: file.replace(".md", ""),
        taskId: taskIdMatch[1],
        title: titleMatch?.[1] || file,
        agent: authorMatch?.[1] || "unknown",
        createdAt: createdMatch?.[1] || "",
        filesModified: [],
        summary: "",
      });
    }
  }
  
  return { docs };
}

/**
 * Получает документацию по taskId
 */
export async function getDocumentation(input: { repoPath?: string; taskId: string }): Promise<{ found: boolean; content: string }> {
  const repoRoot = await getRepoRoot(input.repoPath);
  const docPath = path.join(repoRoot, "swarm", "docs", `${input.taskId}.md`);
  
  if (!fs.existsSync(docPath)) {
    return { found: false, content: "" };
  }
  
  const content = fs.readFileSync(docPath, "utf-8");
  return { found: true, content };
}
