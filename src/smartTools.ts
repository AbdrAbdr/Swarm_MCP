/**
 * MCP Swarm v0.9.4 - Smart Tools
 * 
 * Consolidates 168+ individual tools into 47 Smart Tools with `action` parameter.
 * Each Smart Tool groups related functionality for better UX.
 */

import { z } from "zod";

// ============ IMPORTS FROM WORKFLOWS ============

// Agent & Registry
import { registerAgent, whoami, bootstrapProject } from "./workflows/agentRegistry.js";

// Tasks
import { createTaskFile } from "./workflows/taskFile.js";
import { listTasks, updateTask } from "./workflows/taskState.js";
import { decomposeTask, getDecomposition } from "./workflows/decompose.js";

// Files
import { fileReserve, fileRelease, listFileLocks } from "./workflows/fileLocks.js";
import { forecastFileTouches, checkFileConflicts } from "./workflows/conflictForecast.js";
import { checkFileSafety, predictConflicts, analyzeConflictHistory, getConflictHotspots, recordConflictEvent } from "./workflows/conflictPrediction.js";

// Git
import { syncWithBaseBranch } from "./workflows/git.js";
import { createGithubPr, checkMainHealth } from "./workflows/githubPr.js";
import { autoDeleteMergedBranch, cleanupAllMergedBranches } from "./workflows/remoteCleanup.js";

// Worktree
import { createWorktree, listWorktrees, removeWorktree } from "./workflows/worktree.js";

// Companion Control
import {
  companionLocalPause,
  companionLocalResume,
  companionLocalStatus,
  companionLocalStop,
} from "./workflows/companionControl.js";

// Stop Flag
import { getStopState, setStopState } from "./workflows/stopFlag.js";

// Team Files
import { appendTeamChat, updateTeamStatus } from "./workflows/teamFiles.js";
import { logSwarmThought, getRecentThoughts } from "./workflows/swarmThoughts.js";

// Review
import { requestCrossAgentReview, respondToReview, listPendingReviews } from "./workflows/codeReview.js";

// Screenshot
import { shareScreenshot, listScreenshots } from "./workflows/screenshot.js";

// Voting
import { startVoting, castVote, getVotingSession, listOpenVotings } from "./workflows/voting.js";

// Auction
import { announceTaskForBidding, bidForTask, pollSwarmEvents } from "./workflows/auction.js";

// MCP Scanner
import { scanSystemMcps, authorizeMcpsForSwarm, getPolicy } from "./workflows/mcpScanner.js";

// Dependency
import { signalDependencyChange, syncDependencies } from "./workflows/dependencySync.js";

// Platform
import { requestPlatformCheck, respondToPlatformCheck, getPendingPlatformChecks } from "./workflows/crossPlatform.js";

// Immune System
import { reportCiAlert, resolveAlert, getImmuneStatus, runLocalTests } from "./workflows/immuneSystem.js";
import { patrolMode } from "./workflows/ghostMode.js";

// Briefings
import { saveBriefing, loadBriefing } from "./workflows/briefings.js";

// Pulse
import { updateSwarmPulse, getSwarmPulse } from "./workflows/pulse.js";

// Knowledge
import { archiveFinding, searchKnowledge } from "./workflows/knowledgeBase.js";

// Preemption
import { triggerUrgentPreemption, resolveUrgent, getActiveUrgent } from "./workflows/preemption.js";

// Snapshot
import { createSnapshot, triggerRollback, listSnapshots } from "./workflows/snapshot.js";

// Advice
import { requestCollectiveAdvice, provideAdvice, getOpenAdviceRequests } from "./workflows/collectiveAdvice.js";

// Smart Routing
import {
  recordFileEdit,
  recordMultipleEdits,
  findBestAgent,
  getExpertiseMap,
  predictAffectedPaths,
  autoAssignTask,
} from "./workflows/smartRouting.js";

// Context Pool
import {
  addContextNote,
  getContextNotes,
  searchContextByTag,
  searchContext,
  markNoteHelpful,
  updateContextNote,
  cleanupStaleNotes,
  getContextStats,
} from "./workflows/contextPool.js";

// Auto Review
import {
  createReviewRequest,
  assignReviewer,
  addReviewComment,
  completeReview,
  resolveComment,
  getReviewsForReviewer,
  getReviewsForAuthor,
  getPendingReviews,
  getReviewStats,
} from "./workflows/autoReview.js";

// External Sync
import {
  enableGitHubSync,
  enableLinearSync,
  syncFromGitHub,
  syncFromLinear,
  syncToGitHub,
  syncAll,
  exportTaskToGitHub,
  exportTaskToLinear,
  getSyncStatus,
  createGitHubIssue,
  closeGitHubIssue,
  addGitHubComment,
} from "./workflows/externalSync.js";

// Cost Optimization
import {
  analyzeTaskComplexity,
  getAvailableModels,
  selectModel,
  recommendModel,
  routeTask,
  logUsage,
  getUsage,
  getUsageStats,
  getBudgetConfig,
  setBudgetConfig,
  checkBudget,
  getRemainingBudget,
  generateCostReport,
} from "./workflows/costOptimization.js";

// Telegram Integration
import { handleTelegramTool } from "./integrations/telegram.js";

// Docs
import { autoGenerateDocs, listDocs } from "./workflows/autoDoc.js";
import { generateTaskDocumentation, listDocumentation, getDocumentation } from "./workflows/autoDocumentation.js";

// Expertise
import { trackExpertise, suggestAgentForTask as suggestAgentSimple, getAgentExpertise } from "./workflows/specialization.js";
import { recordAgentEdit, suggestAgentForTask as suggestAgentAdvanced, getTopExperts, listAllAgentExpertise } from "./workflows/agentSpecialization.js";

// Timeline
import { generateTimeline, getTimelineVisualization } from "./workflows/timeline.js";

// Health
import { checkAgentHealth, getDeadAgents, forceReassignTask, getSwarmHealthSummary } from "./workflows/agentHealth.js";

// Session
import { startSessionRecording, logSessionAction, stopSessionRecording, listSessionRecordings, replaySession } from "./workflows/sessionRecording.js";

// Quality
import { runQualityGate, getQualityReport, setQualityThreshold, checkPrReady } from "./workflows/qualityGate.js";

// Cost
import { logApiUsage, getAgentCosts, getProjectCosts, setBudgetLimit, checkBudgetRemaining } from "./workflows/costTracker.js";

// Context
import { estimateContextSize, compressBriefing, compressMultipleBriefings, getCompressionStats } from "./workflows/contextCompressor.js";

// Regression
import { saveBaseline, checkRegression, listRegressions, resolveRegression, listBaselines } from "./workflows/regressionDetector.js";

// Brainstorming
import {
  startBrainstorm,
  askBrainstormQuestion,
  answerBrainstormQuestion,
  proposeApproaches,
  presentDesignSection,
  validateDesignSection,
  saveDesignDocument,
  getBrainstormSession,
  listBrainstormSessions,
} from "./workflows/brainstorming.js";

// Plans
import {
  createImplementationPlan,
  addPlanTask,
  getNextTask,
  startTask,
  completeStep,
  completeTask,
  generateSubagentPrompt,
  exportPlanAsMarkdown,
  getPlanStatus,
  listPlans,
  markPlanReady,
} from "./workflows/writingPlans.js";

// Debug
import {
  startDebugSession,
  logInvestigation,
  addEvidence,
  completePhase1,
  logPatterns,
  completePhase2,
  formHypothesis,
  testHypothesis,
  implementFix,
  verifyFix,
  getDebugSession,
  listDebugSessions,
  checkRedFlags,
} from "./workflows/systematicDebugging.js";

// Spec Pipeline
import {
  startSpecPipeline,
  startSpecPhase,
  completeSpecPhase,
  getSpecPipeline,
  listSpecPipelines,
  exportSpecAsMarkdown,
} from "./workflows/specPipeline.js";

// QA Loop
import {
  startQALoop,
  runQAIteration,
  logQAFix,
  getQALoop,
  listQALoops,
  getQAFixSuggestions,
  generateQAReport,
} from "./workflows/qaLoop.js";

// Guard Hooks
import {
  installGuardHooks,
  uninstallGuardHooks,
  runGuardHooks,
  getGuardConfig,
  updateGuardHook,
  listGuardHooks,
} from "./workflows/guardHooks.js";

// Tool Clusters
import {
  initToolClusters,
  listToolClusters,
  getClusterTools,
  findToolCluster,
  addToolToCluster,
  createToolCluster,
  getToolClusterSummary,
} from "./workflows/toolClusters.js";

// Orchestrator
import {
  tryBecomeOrchestrator,
  getOrchestratorInfo,
  orchestratorHeartbeat,
  resignOrchestrator,
  listExecutors,
  executorHeartbeat,
  sendAgentMessage,
  fetchAgentInbox,
  acknowledgeMessage,
  replyToMessage,
  searchMessages,
  getThreadMessages,
} from "./workflows/orchestrator.js";

// Helper to wrap results
function wrapResult(result: any) {
  return { content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }], structuredContent: result };
}

// ============ SMART TOOLS ============

/**
 * 1. swarm_agent - Agent registration and identity
 */
export const swarmAgentTool = [
  "swarm_agent",
  {
    title: "Swarm Agent",
    description: "Agent registration and identity. Actions: register, whoami, init",
    inputSchema: z.object({
      action: z.enum(["register", "whoami", "init"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: { action: string; repoPath?: string; commitMode?: "none" | "local" | "push" }) => {
    switch (input.action) {
      case "register":
        return wrapResult(await registerAgent({ repoPath: input.repoPath, commitMode: input.commitMode || "push" }));
      case "whoami":
        return wrapResult(await whoami(input.repoPath || process.cwd()));
      case "init":
        return wrapResult(await bootstrapProject(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 2. swarm_task - Task management
 */
export const swarmTaskTool = [
  "swarm_task",
  {
    title: "Swarm Task",
    description: "Task management. Actions: create, list, update, decompose, get_decomposition",
    inputSchema: z.object({
      action: z.enum(["create", "list", "update", "decompose", "get_decomposition"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // create params
      shortDesc: z.string().optional().describe("Short description (for create)"),
      title: z.string().optional().describe("Task title (for create)"),
      questions: z.array(z.string()).optional().describe("Questions (for create)"),
      answers: z.array(z.string()).optional().describe("Answers (for create)"),
      notes: z.string().optional().describe("Notes (for create)"),
      // update params
      taskId: z.string().optional().describe("Task ID (for update, decompose, get_decomposition)"),
      status: z.enum(["open", "in_progress", "needs_review", "done", "canceled"]).optional().describe("Status (for update)"),
      assignee: z.string().optional().describe("Assignee (for update)"),
      branch: z.string().optional().describe("Branch (for update)"),
      links: z.array(z.string()).optional().describe("Links (for update)"),
      // decompose params
      parentTitle: z.string().optional().describe("Parent title (for decompose)"),
      subtasks: z.array(z.object({
        title: z.string(),
        description: z.string().optional(),
        estimatedMinutes: z.number().optional(),
        dependencies: z.array(z.string()).optional(),
      })).optional().describe("Subtasks (for decompose)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const commitMode = input.commitMode || "push";
    
    switch (input.action) {
      case "create":
        return wrapResult(await createTaskFile({
          repoPath: input.repoPath,
          shortDesc: input.shortDesc,
          title: input.title,
          questions: input.questions || [],
          answers: input.answers || [],
          notes: input.notes,
          commitMode,
        }));
      case "list":
        return wrapResult(await listTasks(input.repoPath));
      case "update":
        return wrapResult(await updateTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          status: input.status,
          assignee: input.assignee,
          branch: input.branch,
          links: input.links,
          commitMode,
        }));
      case "decompose":
        return wrapResult(await decomposeTask({
          repoPath: input.repoPath,
          parentTaskId: input.taskId,
          parentTitle: input.parentTitle,
          subtasks: input.subtasks || [],
          commitMode,
        }));
      case "get_decomposition":
        return wrapResult(await getDecomposition({
          repoPath: input.repoPath,
          parentTaskId: input.taskId,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 3. swarm_file - File locking and conflict management
 */
export const swarmFileTool = [
  "swarm_file",
  {
    title: "Swarm File",
    description: "File locking and conflict management. Actions: reserve, release, list, forecast, conflicts, safety",
    inputSchema: z.object({
      action: z.enum(["reserve", "release", "list", "forecast", "conflicts", "safety"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      filePath: z.string().optional().describe("File path (for reserve, release, safety)"),
      files: z.array(z.string()).optional().describe("Files (for forecast, conflicts)"),
      agent: z.string().optional().describe("Agent name"),
      exclusive: z.boolean().optional().default(true).describe("Exclusive lock (for reserve)"),
      ttlMs: z.number().optional().describe("TTL in ms (for reserve)"),
      taskId: z.string().optional().describe("Task ID (for forecast)"),
      estimatedMinutesFromNow: z.number().optional().describe("Estimated minutes (for forecast)"),
      confidence: z.enum(["low", "medium", "high"]).optional().describe("Confidence (for forecast)"),
      excludeAgent: z.string().optional().describe("Exclude agent (for conflicts)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "reserve":
        return wrapResult(await fileReserve({
          repoPath: input.repoPath,
          filePath: input.filePath,
          agent: input.agent,
          exclusive: input.exclusive ?? true,
          ttlMs: input.ttlMs,
          commitMode: input.commitMode || "push",
        }));
      case "release":
        return wrapResult(await fileRelease({
          repoPath: input.repoPath,
          filePath: input.filePath,
          agent: input.agent,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listFileLocks(input.repoPath));
      case "forecast":
        return wrapResult(await forecastFileTouches({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          files: input.files || [],
          estimatedMinutesFromNow: input.estimatedMinutesFromNow,
          confidence: input.confidence,
          commitMode: input.commitMode || "push",
        }));
      case "conflicts":
        return wrapResult(await checkFileConflicts({
          repoPath: input.repoPath,
          files: input.files || [],
          excludeAgent: input.excludeAgent,
        }));
      case "safety":
        return wrapResult(await checkFileSafety({
          repoPath: input.repoPath,
          file: input.filePath,
          agent: input.agent,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 4. swarm_git - Git operations
 */
export const swarmGitTool = [
  "swarm_git",
  {
    title: "Swarm Git",
    description: "Git operations. Actions: sync, pr, health, cleanup, cleanup_all",
    inputSchema: z.object({
      action: z.enum(["sync", "pr", "health", "cleanup", "cleanup_all"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      baseBranch: z.string().optional().describe("Base branch"),
      title: z.string().optional().describe("PR title (for pr)"),
      body: z.string().optional().describe("PR body (for pr)"),
      draft: z.boolean().optional().describe("Draft PR (for pr)"),
      branch: z.string().optional().describe("Branch name (for cleanup)"),
      deleteLocal: z.boolean().optional().describe("Delete local (for cleanup)"),
      deleteRemote: z.boolean().optional().describe("Delete remote (for cleanup)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const { getRepoRoot } = await import("./workflows/repo.js");
    const repoRoot = await getRepoRoot(input.repoPath);
    
    switch (input.action) {
      case "sync":
        return wrapResult(await syncWithBaseBranch({
          repoRoot,
          baseBranch: input.baseBranch,
        }));
      case "pr":
        return wrapResult(await createGithubPr({
          repoPath: input.repoPath,
          title: input.title,
          body: input.body,
          baseBranch: input.baseBranch,
          draft: input.draft,
        }));
      case "health":
        return wrapResult(await checkMainHealth({
          repoPath: input.repoPath,
          baseBranch: input.baseBranch,
        }));
      case "cleanup":
        return wrapResult(await autoDeleteMergedBranch({
          repoPath: input.repoPath,
          branch: input.branch,
          deleteLocal: input.deleteLocal,
          deleteRemote: input.deleteRemote,
        }));
      case "cleanup_all":
        return wrapResult(await cleanupAllMergedBranches({
          repoPath: input.repoPath,
          deleteLocal: input.deleteLocal,
          deleteRemote: input.deleteRemote,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 5. swarm_worktree - Git worktree management
 */
export const swarmWorktreeTool = [
  "swarm_worktree",
  {
    title: "Swarm Worktree",
    description: "Git worktree management. Actions: create, list, remove",
    inputSchema: z.object({
      action: z.enum(["create", "list", "remove"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentName: z.string().optional().describe("Agent name (for create)"),
      shortDesc: z.string().optional().describe("Short description (for create)"),
      baseRef: z.string().optional().describe("Base ref (for create)"),
      push: z.boolean().optional().describe("Push (for create)"),
      worktreePath: z.string().optional().describe("Worktree path (for remove)"),
      force: z.boolean().optional().describe("Force remove (for remove)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "create":
        return wrapResult(await createWorktree({
          repoPath: input.repoPath,
          agentName: input.agentName,
          shortDesc: input.shortDesc,
          baseRef: input.baseRef || "main",
          push: input.push ?? true,
        }));
      case "list":
        return wrapResult(await listWorktrees({ repoPath: input.repoPath }));
      case "remove":
        return wrapResult(await removeWorktree({
          worktreePath: input.worktreePath,
          force: input.force ?? false,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 6. swarm_companion - Companion daemon control
 */
export const swarmCompanionTool = [
  "swarm_companion",
  {
    title: "Swarm Companion",
    description: "Companion daemon control. Actions: status, stop, pause, resume",
    inputSchema: z.object({
      action: z.enum(["status", "stop", "pause", "resume"]).describe("Action to perform"),
      port: z.number().optional().default(9999).describe("Companion port"),
      token: z.string().optional().describe("Auth token"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: { action: string; port?: number; token?: string }) => {
    const port = input.port || 9999;
    switch (input.action) {
      case "status":
        return wrapResult(await companionLocalStatus(port, input.token));
      case "stop":
        return wrapResult(await companionLocalStop(port, input.token));
      case "pause":
        return wrapResult(await companionLocalPause(port, input.token));
      case "resume":
        return wrapResult(await companionLocalResume(port, input.token));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 7. swarm_control - Swarm stop/resume control
 */
export const swarmControlTool = [
  "swarm_control",
  {
    title: "Swarm Control",
    description: "Swarm stop/resume control. Actions: stop, resume, status",
    inputSchema: z.object({
      action: z.enum(["stop", "resume", "status"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      reason: z.string().optional().describe("Reason for stop"),
      by: z.string().optional().describe("Agent who stopped"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "stop":
        return wrapResult(await setStopState({
          repoPath: input.repoPath,
          stopped: true,
          reason: input.reason,
          by: input.by,
          commitMode: input.commitMode || "push",
        }));
      case "resume":
        return wrapResult(await setStopState({
          repoPath: input.repoPath,
          stopped: false,
          commitMode: input.commitMode || "push",
        }));
      case "status":
        return wrapResult(await getStopState(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 8. swarm_chat - Team communication
 */
export const swarmChatTool = [
  "swarm_chat",
  {
    title: "Swarm Chat",
    description: "Team communication. Actions: broadcast, dashboard, thought, thoughts",
    inputSchema: z.object({
      action: z.enum(["broadcast", "dashboard", "thought", "thoughts"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      message: z.string().optional().describe("Message (for broadcast, thought)"),
      statusLine: z.string().optional().describe("Status line (for dashboard)"),
      agent: z.string().optional().describe("Agent name (for thought)"),
      taskId: z.string().optional().describe("Task ID (for thought)"),
      context: z.string().optional().describe("Context (for thought)"),
      limit: z.number().optional().describe("Limit (for thoughts)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "broadcast":
        return wrapResult(await appendTeamChat({
          repoPath: input.repoPath,
          message: input.message,
          commitMode: input.commitMode || "push",
        }));
      case "dashboard":
        return wrapResult(await updateTeamStatus({
          repoPath: input.repoPath,
          statusLine: input.statusLine,
          commitMode: input.commitMode || "push",
        }));
      case "thought":
        return wrapResult(await logSwarmThought({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          thought: input.message,
          context: input.context,
          commitMode: input.commitMode || "push",
        }));
      case "thoughts":
        return wrapResult(await getRecentThoughts({
          repoPath: input.repoPath,
          limit: input.limit,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 9. swarm_review - Code review between agents
 */
export const swarmReviewTool = [
  "swarm_review",
  {
    title: "Swarm Review",
    description: "Code review between agents. Actions: request, respond, list",
    inputSchema: z.object({
      action: z.enum(["request", "respond", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      fromAgent: z.string().optional().describe("Requesting agent (for request)"),
      toAgent: z.string().optional().describe("Target agent (for request)"),
      reviewId: z.string().optional().describe("Review ID (for respond)"),
      status: z.enum(["approved", "rejected"]).optional().describe("Review status (for respond)"),
      comment: z.string().optional().describe("Comment (for respond)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "request":
        return wrapResult(await requestCrossAgentReview({
          repoPath: input.repoPath,
          fromAgent: input.fromAgent,
          toAgent: input.toAgent,
          commitMode: input.commitMode || "push",
        }));
      case "respond":
        return wrapResult(await respondToReview({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          status: input.status,
          comment: input.comment,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listPendingReviews(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 10. swarm_voting - Voting for dangerous actions
 */
export const swarmVotingTool = [
  "swarm_voting",
  {
    title: "Swarm Voting",
    description: "Voting for dangerous actions. Actions: start, vote, list, get",
    inputSchema: z.object({
      action: z.enum(["start", "vote", "list", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      votingId: z.string().optional().describe("Voting ID (for vote, get)"),
      initiator: z.string().optional().describe("Initiator (for start)"),
      actionDesc: z.string().optional().describe("Action description (for start)"),
      description: z.string().optional().describe("Description (for start)"),
      dangerLevel: z.enum(["low", "medium", "high", "critical"]).optional().describe("Danger level (for start)"),
      ttlMinutes: z.number().optional().describe("TTL minutes (for start)"),
      agent: z.string().optional().describe("Voting agent (for vote)"),
      decision: z.enum(["approve", "reject"]).optional().describe("Decision (for vote)"),
      reason: z.string().optional().describe("Reason (for vote)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startVoting({
          repoPath: input.repoPath,
          initiator: input.initiator,
          action: input.actionDesc,
          description: input.description,
          dangerLevel: input.dangerLevel,
          ttlMinutes: input.ttlMinutes,
          commitMode: input.commitMode || "push",
        }));
      case "vote":
        return wrapResult(await castVote({
          repoPath: input.repoPath,
          votingId: input.votingId,
          agent: input.agent,
          decision: input.decision,
          reason: input.reason,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listOpenVotings(input.repoPath));
      case "get":
        return wrapResult(await getVotingSession({
          repoPath: input.repoPath,
          votingId: input.votingId,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 11. swarm_auction - Task auction system
 */
export const swarmAuctionTool = [
  "swarm_auction",
  {
    title: "Swarm Auction",
    description: "Task auction system. Actions: announce, bid, poll",
    inputSchema: z.object({
      action: z.enum(["announce", "bid", "poll"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID"),
      title: z.string().optional().describe("Task title (for announce)"),
      requiredCapabilities: z.array(z.string()).optional().describe("Required capabilities (for announce)"),
      agent: z.string().optional().describe("Agent name (for bid)"),
      capabilities: z.array(z.string()).optional().describe("Agent capabilities (for bid)"),
      since: z.number().optional().describe("Timestamp (for poll)"),
      types: z.array(z.string()).optional().describe("Event types (for poll)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "announce":
        return wrapResult(await announceTaskForBidding({
          repoPath: input.repoPath,
          taskId: input.taskId,
          title: input.title,
          requiredCapabilities: input.requiredCapabilities,
          commitMode: input.commitMode || "push",
        }));
      case "bid":
        return wrapResult(await bidForTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          agent: input.agent,
          capabilities: input.capabilities || [],
          commitMode: input.commitMode || "push",
        }));
      case "poll":
        return wrapResult(await pollSwarmEvents({
          repoPath: input.repoPath,
          since: input.since,
          types: input.types,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 12. swarm_mcp - MCP scanner and authorization
 */
export const swarmMcpTool = [
  "swarm_mcp",
  {
    title: "Swarm MCP",
    description: "MCP scanner and authorization. Actions: scan, authorize, policy",
    inputSchema: z.object({
      action: z.enum(["scan", "authorize", "policy"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      authorizedMcps: z.array(z.string()).optional().describe("MCPs to authorize"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "scan":
        return wrapResult(await scanSystemMcps());
      case "authorize":
        return wrapResult(await authorizeMcpsForSwarm({
          repoPath: input.repoPath,
          authorizedMcps: input.authorizedMcps || [],
          commitMode: input.commitMode || "push",
        }));
      case "policy":
        return wrapResult(await getPolicy(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 13. swarm_orchestrator - Orchestrator election and management
 */
export const swarmOrchestratorTool = [
  "swarm_orchestrator",
  {
    title: "Swarm Orchestrator",
    description: "Orchestrator election and management. Actions: elect, info, heartbeat, resign, executors, executor_heartbeat",
    inputSchema: z.object({
      action: z.enum(["elect", "info", "heartbeat", "resign", "executors", "executor_heartbeat"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentId: z.string().optional().describe("Agent ID"),
      agentName: z.string().optional().describe("Agent name (for elect)"),
      platform: z.string().optional().describe("Platform (for elect)"),
      currentTask: z.string().optional().describe("Current task (for executor_heartbeat)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "elect":
        return wrapResult(await tryBecomeOrchestrator({
          repoPath: input.repoPath,
          agentId: input.agentId,
          agentName: input.agentName,
          platform: input.platform,
        }));
      case "info":
        return wrapResult(await getOrchestratorInfo({ repoPath: input.repoPath }));
      case "heartbeat":
        return wrapResult(await orchestratorHeartbeat({
          repoPath: input.repoPath,
          agentId: input.agentId,
        }));
      case "resign":
        return wrapResult(await resignOrchestrator({
          repoPath: input.repoPath,
          agentId: input.agentId,
        }));
      case "executors":
        return wrapResult(await listExecutors({ repoPath: input.repoPath }));
      case "executor_heartbeat":
        return wrapResult(await executorHeartbeat({
          repoPath: input.repoPath,
          agentId: input.agentId,
          currentTask: input.currentTask,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 14. swarm_message - Agent messaging system
 */
export const swarmMessageTool = [
  "swarm_message",
  {
    title: "Swarm Message",
    description: "Agent messaging system. Actions: send, inbox, ack, reply, search, thread",
    inputSchema: z.object({
      action: z.enum(["send", "inbox", "ack", "reply", "search", "thread"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      from: z.string().optional().describe("Sender (for send, reply)"),
      to: z.union([z.string(), z.array(z.string())]).optional().describe("Recipients (for send)"),
      subject: z.string().optional().describe("Subject (for send)"),
      body: z.string().optional().describe("Body (for send, reply)"),
      importance: z.enum(["low", "normal", "high", "urgent"]).optional(),
      threadId: z.string().optional().describe("Thread ID"),
      replyTo: z.string().optional().describe("Reply to message ID"),
      ackRequired: z.boolean().optional(),
      agentName: z.string().optional().describe("Agent name (for inbox, ack)"),
      messageId: z.string().optional().describe("Message ID (for ack, reply)"),
      query: z.string().optional().describe("Search query"),
      limit: z.number().optional(),
      urgentOnly: z.boolean().optional(),
      sinceTs: z.number().optional(),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "send":
        return wrapResult(await sendAgentMessage({
          repoPath: input.repoPath,
          from: input.from,
          to: input.to,
          subject: input.subject,
          body: input.body,
          importance: input.importance,
          threadId: input.threadId,
          replyTo: input.replyTo,
          ackRequired: input.ackRequired,
        }));
      case "inbox":
        return wrapResult(await fetchAgentInbox({
          repoPath: input.repoPath,
          agentName: input.agentName,
          limit: input.limit,
          urgentOnly: input.urgentOnly,
          sinceTs: input.sinceTs,
        }));
      case "ack":
        return wrapResult(await acknowledgeMessage({
          repoPath: input.repoPath,
          agentName: input.agentName,
          messageId: input.messageId,
        }));
      case "reply":
        return wrapResult(await replyToMessage({
          repoPath: input.repoPath,
          from: input.from,
          messageId: input.messageId,
          body: input.body,
        }));
      case "search":
        return wrapResult(await searchMessages({
          repoPath: input.repoPath,
          query: input.query,
          limit: input.limit,
        }));
      case "thread":
        return wrapResult(await getThreadMessages({
          repoPath: input.repoPath,
          threadId: input.threadId,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ============ SMART TOOLS 15-27 ============

/**
 * 15. swarm_briefing - Briefing management
 */
export const swarmBriefingTool = [
  "swarm_briefing",
  {
    title: "Swarm Briefing",
    description: "Agent briefing management. Actions: save, load",
    inputSchema: z.object({
      action: z.enum(["save", "load"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID"),
      agent: z.string().optional().describe("Agent name"),
      filesWorkedOn: z.array(z.string()).optional().describe("Files worked on (for save)"),
      currentState: z.string().optional().describe("Current state (for save)"),
      nextSteps: z.array(z.string()).optional().describe("Next steps (for save)"),
      blockers: z.array(z.string()).optional().describe("Blockers (for save)"),
      notes: z.string().optional().describe("Notes (for save)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "save":
        return wrapResult(await saveBriefing({
          repoPath: input.repoPath,
          taskId: input.taskId,
          agent: input.agent,
          filesWorkedOn: input.filesWorkedOn || [],
          currentState: input.currentState,
          nextSteps: input.nextSteps || [],
          blockers: input.blockers,
          notes: input.notes,
          commitMode: input.commitMode || "push",
        }));
      case "load":
        return wrapResult(await loadBriefing({
          repoPath: input.repoPath,
          taskId: input.taskId,
          agent: input.agent,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 16. swarm_pulse - Real-time agent status
 */
export const swarmPulseTool = [
  "swarm_pulse",
  {
    title: "Swarm Pulse",
    description: "Real-time agent status. Actions: update, get",
    inputSchema: z.object({
      action: z.enum(["update", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for update)"),
      currentFile: z.string().optional().describe("Current file (for update)"),
      currentTask: z.string().optional().describe("Current task (for update)"),
      status: z.enum(["active", "idle", "paused", "offline"]).optional().describe("Status (for update)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "update":
        return wrapResult(await updateSwarmPulse({
          repoPath: input.repoPath,
          agent: input.agent,
          currentFile: input.currentFile,
          currentTask: input.currentTask,
          status: input.status || "active",
          commitMode: input.commitMode || "push",
        }));
      case "get":
        return wrapResult(await getSwarmPulse(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 17. swarm_knowledge - Knowledge base management
 */
export const swarmKnowledgeTool = [
  "swarm_knowledge",
  {
    title: "Swarm Knowledge",
    description: "Knowledge base management. Actions: archive, search",
    inputSchema: z.object({
      action: z.enum(["archive", "search"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for archive)"),
      category: z.enum(["bug", "workaround", "pattern", "config", "dependency", "architecture", "other"]).optional().describe("Category"),
      title: z.string().optional().describe("Title (for archive)"),
      description: z.string().optional().describe("Description (for archive)"),
      solution: z.string().optional().describe("Solution (for archive)"),
      relatedFiles: z.array(z.string()).optional().describe("Related files (for archive)"),
      tags: z.array(z.string()).optional().describe("Tags"),
      query: z.string().optional().describe("Search query (for search)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "archive":
        return wrapResult(await archiveFinding({
          repoPath: input.repoPath,
          agent: input.agent,
          category: input.category || "other",
          title: input.title,
          description: input.description,
          solution: input.solution,
          relatedFiles: input.relatedFiles,
          tags: input.tags,
          commitMode: input.commitMode || "push",
        }));
      case "search":
        return wrapResult(await searchKnowledge({
          repoPath: input.repoPath,
          query: input.query,
          category: input.category,
          tags: input.tags,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 18. swarm_snapshot - File snapshots for rollback
 */
export const swarmSnapshotTool = [
  "swarm_snapshot",
  {
    title: "Swarm Snapshot",
    description: "File snapshots for rollback. Actions: create, rollback, list",
    inputSchema: z.object({
      action: z.enum(["create", "rollback", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      taskId: z.string().optional().describe("Task ID"),
      files: z.array(z.string()).optional().describe("Files to snapshot (for create)"),
      snapshotId: z.string().optional().describe("Snapshot ID (for rollback)"),
      reason: z.string().optional().describe("Reason (for rollback)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "create":
        return wrapResult(await createSnapshot({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          files: input.files || [],
          commitMode: input.commitMode || "push",
        }));
      case "rollback":
        return wrapResult(await triggerRollback({
          repoPath: input.repoPath,
          snapshotId: input.snapshotId,
          agent: input.agent,
          reason: input.reason,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listSnapshots({
          repoPath: input.repoPath,
          taskId: input.taskId,
          agent: input.agent,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 19. swarm_health - Agent health monitoring
 */
export const swarmHealthTool = [
  "swarm_health",
  {
    title: "Swarm Health",
    description: "Agent health monitoring. Actions: check, dead, reassign, summary",
    inputSchema: z.object({
      action: z.enum(["check", "dead", "reassign", "summary"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for check)"),
      thresholdMinutes: z.number().optional().describe("Threshold minutes"),
      taskId: z.string().optional().describe("Task ID (for reassign)"),
      fromAgent: z.string().optional().describe("From agent (for reassign)"),
      toAgent: z.string().optional().describe("To agent (for reassign)"),
      reason: z.string().optional().describe("Reason (for reassign)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "check":
        return wrapResult(await checkAgentHealth({
          repoPath: input.repoPath,
          agent: input.agent,
          thresholdMinutes: input.thresholdMinutes,
        }));
      case "dead":
        return wrapResult(await getDeadAgents({
          repoPath: input.repoPath,
          thresholdMinutes: input.thresholdMinutes,
        }));
      case "reassign":
        return wrapResult(await forceReassignTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          fromAgent: input.fromAgent,
          toAgent: input.toAgent,
          reason: input.reason,
          commitMode: input.commitMode || "push",
        }));
      case "summary":
        return wrapResult(await getSwarmHealthSummary({
          repoPath: input.repoPath,
          thresholdMinutes: input.thresholdMinutes,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 20. swarm_quality - Quality gate checks
 */
export const swarmQualityTool = [
  "swarm_quality",
  {
    title: "Swarm Quality",
    description: "Quality gate checks. Actions: run, report, threshold, pr_ready",
    inputSchema: z.object({
      action: z.enum(["run", "report", "threshold", "pr_ready"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      runLint: z.boolean().optional().describe("Run lint (for run)"),
      runTests: z.boolean().optional().describe("Run tests (for run)"),
      runTypeCheck: z.boolean().optional().describe("Run type check (for run)"),
      branch: z.string().optional().describe("Branch (for report, pr_ready)"),
      maxLintErrors: z.number().optional().describe("Max lint errors (for threshold)"),
      maxLintWarnings: z.number().optional().describe("Max lint warnings (for threshold)"),
      minTestCoverage: z.number().optional().describe("Min test coverage (for threshold)"),
      requireAllTestsPass: z.boolean().optional().describe("Require all tests pass (for threshold)"),
      requireTypeCheck: z.boolean().optional().describe("Require type check (for threshold)"),
      runFreshCheck: z.boolean().optional().describe("Run fresh check (for pr_ready)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "run":
        return wrapResult(await runQualityGate({
          repoPath: input.repoPath,
          runLint: input.runLint,
          runTests: input.runTests,
          runTypeCheck: input.runTypeCheck,
          commitMode: input.commitMode || "push",
        }));
      case "report":
        return wrapResult(await getQualityReport({
          repoPath: input.repoPath,
          branch: input.branch,
        }));
      case "threshold":
        return wrapResult(await setQualityThreshold({
          repoPath: input.repoPath,
          maxLintErrors: input.maxLintErrors,
          maxLintWarnings: input.maxLintWarnings,
          minTestCoverage: input.minTestCoverage,
          requireAllTestsPass: input.requireAllTestsPass,
          requireTypeCheck: input.requireTypeCheck,
          commitMode: input.commitMode || "push",
        }));
      case "pr_ready":
        return wrapResult(await checkPrReady({
          repoPath: input.repoPath,
          branch: input.branch,
          runFreshCheck: input.runFreshCheck,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 21. swarm_cost - API cost tracking
 */
export const swarmCostTool = [
  "swarm_cost",
  {
    title: "Swarm Cost",
    description: "API cost tracking. Actions: log, agent, project, limit, remaining",
    inputSchema: z.object({
      action: z.enum(["log", "agent", "project", "limit", "remaining"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      model: z.string().optional().describe("Model name (for log)"),
      inputTokens: z.number().optional().describe("Input tokens (for log)"),
      outputTokens: z.number().optional().describe("Output tokens (for log)"),
      taskId: z.string().optional().describe("Task ID (for log)"),
      tool: z.string().optional().describe("Tool name (for log)"),
      periodDays: z.number().optional().describe("Period days (for agent, project)"),
      dailyLimit: z.number().optional().describe("Daily limit (for limit)"),
      monthlyLimit: z.number().optional().describe("Monthly limit (for limit)"),
      perAgentLimit: z.number().optional().describe("Per agent limit (for limit)"),
      alertThreshold: z.number().optional().describe("Alert threshold (for limit)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "log":
        return wrapResult(await logApiUsage({
          repoPath: input.repoPath,
          agent: input.agent,
          model: input.model,
          inputTokens: input.inputTokens,
          outputTokens: input.outputTokens,
          taskId: input.taskId,
          tool: input.tool,
        }));
      case "agent":
        return wrapResult(await getAgentCosts({
          repoPath: input.repoPath,
          agent: input.agent,
          periodDays: input.periodDays,
        }));
      case "project":
        return wrapResult(await getProjectCosts({
          repoPath: input.repoPath,
          periodDays: input.periodDays,
        }));
      case "limit":
        return wrapResult(await setBudgetLimit({
          repoPath: input.repoPath,
          dailyLimit: input.dailyLimit,
          monthlyLimit: input.monthlyLimit,
          perAgentLimit: input.perAgentLimit,
          alertThreshold: input.alertThreshold,
          commitMode: input.commitMode || "push",
        }));
      case "remaining":
        return wrapResult(await checkBudgetRemaining({
          repoPath: input.repoPath,
          agent: input.agent,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 22. swarm_brainstorm - Brainstorming sessions
 */
export const swarmBrainstormTool = [
  "swarm_brainstorm",
  {
    title: "Swarm Brainstorm",
    description: "Brainstorming sessions. Actions: start, ask, answer, propose, present, validate, save, get, list",
    inputSchema: z.object({
      action: z.enum(["start", "ask", "answer", "propose", "present", "validate", "save", "get", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentId: z.string().optional().describe("Agent ID (for start)"),
      taskId: z.string().optional().describe("Task ID (for start)"),
      taskDescription: z.string().optional().describe("Task description (for start)"),
      sessionId: z.string().optional().describe("Session ID"),
      question: z.string().optional().describe("Question (for ask)"),
      questionType: z.string().optional().describe("Question type (for ask)"),
      options: z.array(z.string()).optional().describe("Options (for ask)"),
      questionCategory: z.string().optional().describe("Question category (for ask)"),
      questionId: z.string().optional().describe("Question ID (for answer)"),
      answer: z.string().optional().describe("Answer (for answer)"),
      approaches: z.array(z.object({
        name: z.string(),
        description: z.string(),
        pros: z.array(z.string()).optional(),
        cons: z.array(z.string()).optional(),
      })).optional().describe("Approaches (for propose)"),
      title: z.string().optional().describe("Title (for present, save)"),
      content: z.string().optional().describe("Content (for present)"),
      category: z.string().optional().describe("Category (for present)"),
      sectionId: z.string().optional().describe("Section ID (for validate)"),
      approved: z.boolean().optional().describe("Approved (for validate)"),
      feedback: z.string().optional().describe("Feedback (for validate)"),
      summary: z.string().optional().describe("Summary (for save)"),
      status: z.string().optional().describe("Status filter (for list)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startBrainstorm({
          agentId: input.agentId,
          taskId: input.taskId,
          taskDescription: input.taskDescription,
          repoPath: input.repoPath,
        }));
      case "ask":
        return wrapResult(await askBrainstormQuestion({
          sessionId: input.sessionId,
          question: input.question,
          type: input.questionType,
          options: input.options,
          category: input.questionCategory,
          repoPath: input.repoPath,
        }));
      case "answer":
        return wrapResult(await answerBrainstormQuestion({
          sessionId: input.sessionId,
          questionId: input.questionId,
          answer: input.answer,
          repoPath: input.repoPath,
        }));
      case "propose":
        return wrapResult(await proposeApproaches({
          sessionId: input.sessionId,
          approaches: input.approaches || [],
          repoPath: input.repoPath,
        }));
      case "present":
        return wrapResult(await presentDesignSection({
          sessionId: input.sessionId,
          title: input.title,
          content: input.content,
          category: input.category,
          repoPath: input.repoPath,
        }));
      case "validate":
        return wrapResult(await validateDesignSection({
          sessionId: input.sessionId,
          sectionId: input.sectionId,
          approved: input.approved ?? true,
          feedback: input.feedback,
          repoPath: input.repoPath,
        }));
      case "save":
        return wrapResult(await saveDesignDocument({
          sessionId: input.sessionId,
          title: input.title,
          summary: input.summary,
          repoPath: input.repoPath,
        }));
      case "get":
        return wrapResult(await getBrainstormSession({
          sessionId: input.sessionId,
          repoPath: input.repoPath,
        }));
      case "list":
        return wrapResult(await listBrainstormSessions({
          status: input.status,
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 23. swarm_plan - Implementation plan management
 */
export const swarmPlanTool = [
  "swarm_plan",
  {
    title: "Swarm Plan",
    description: "Implementation plan management. Actions: create, add, next, start, step, complete, prompt, export, status, list, ready",
    inputSchema: z.object({
      action: z.enum(["create", "add", "next", "start", "step", "complete", "prompt", "export", "status", "list", "ready"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      name: z.string().optional().describe("Plan name (for create)"),
      goal: z.string().optional().describe("Goal (for create)"),
      architecture: z.string().optional().describe("Architecture (for create)"),
      techStack: z.string().optional().describe("Tech stack (for create)"),
      designDocPath: z.string().optional().describe("Design doc path (for create)"),
      createdBy: z.string().optional().describe("Created by (for create)"),
      planId: z.string().optional().describe("Plan ID"),
      taskId: z.string().optional().describe("Task ID"),
      title: z.string().optional().describe("Task title (for add)"),
      description: z.string().optional().describe("Task description (for add)"),
      files: z.array(z.string()).optional().describe("Files (for add)"),
      testCode: z.string().optional().describe("Test code (for add)"),
      implementationCode: z.string().optional().describe("Implementation code (for add)"),
      testCommand: z.string().optional().describe("Test command (for add)"),
      commitMessage: z.string().optional().describe("Commit message (for add)"),
      dependsOn: z.array(z.string()).optional().describe("Dependencies (for add)"),
      assignedTo: z.string().optional().describe("Assigned to (for start)"),
      stepNumber: z.number().optional().describe("Step number (for step)"),
      reviewResult: z.string().optional().describe("Review result (for complete)"),
      contextFiles: z.array(z.string()).optional().describe("Context files (for prompt)"),
      executionMode: z.string().optional().describe("Execution mode (for ready)"),
      statusFilter: z.string().optional().describe("Status filter (for list)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "create":
        return wrapResult(await createImplementationPlan({
          name: input.name,
          goal: input.goal,
          architecture: input.architecture,
          techStack: input.techStack,
          designDocPath: input.designDocPath,
          createdBy: input.createdBy,
          repoPath: input.repoPath,
        }));
      case "add":
        return wrapResult(await addPlanTask({
          planId: input.planId,
          title: input.title,
          description: input.description,
          files: input.files || [],
          testCode: input.testCode,
          implementationCode: input.implementationCode,
          testCommand: input.testCommand,
          commitMessage: input.commitMessage,
          dependsOn: input.dependsOn,
          repoPath: input.repoPath,
        }));
      case "next":
        return wrapResult(await getNextTask({
          planId: input.planId,
          repoPath: input.repoPath,
        }));
      case "start":
        return wrapResult(await startTask({
          planId: input.planId,
          taskId: input.taskId,
          assignedTo: input.assignedTo,
          repoPath: input.repoPath,
        }));
      case "step":
        return wrapResult(await completeStep({
          planId: input.planId,
          taskId: input.taskId,
          stepNumber: input.stepNumber,
          repoPath: input.repoPath,
        }));
      case "complete":
        return wrapResult(await completeTask({
          planId: input.planId,
          taskId: input.taskId,
          reviewResult: input.reviewResult,
          repoPath: input.repoPath,
        }));
      case "prompt":
        return wrapResult(await generateSubagentPrompt({
          planId: input.planId,
          taskId: input.taskId,
          contextFiles: input.contextFiles,
          repoPath: input.repoPath,
        }));
      case "export":
        return wrapResult(await exportPlanAsMarkdown({
          planId: input.planId,
          repoPath: input.repoPath,
        }));
      case "status":
        return wrapResult(await getPlanStatus({
          planId: input.planId,
          repoPath: input.repoPath,
        }));
      case "list":
        return wrapResult(await listPlans({
          status: input.statusFilter,
          repoPath: input.repoPath,
        }));
      case "ready":
        return wrapResult(await markPlanReady({
          planId: input.planId,
          executionMode: input.executionMode,
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 24. swarm_debug - Systematic debugging
 */
export const swarmDebugTool = [
  "swarm_debug",
  {
    title: "Swarm Debug",
    description: "Systematic debugging. Actions: start, investigate, evidence, phase1, patterns, phase2, hypothesis, test, fix, verify, get, list, redflags",
    inputSchema: z.object({
      action: z.enum(["start", "investigate", "evidence", "phase1", "patterns", "phase2", "hypothesis", "test", "fix", "verify", "get", "list", "redflags"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentId: z.string().optional().describe("Agent ID (for start)"),
      title: z.string().optional().describe("Title (for start)"),
      description: z.string().optional().describe("Description (for start)"),
      errorMessage: z.string().optional().describe("Error message (for start)"),
      stackTrace: z.string().optional().describe("Stack trace (for start)"),
      reproductionSteps: z.array(z.string()).optional().describe("Reproduction steps (for start)"),
      sessionId: z.string().optional().describe("Session ID"),
      errorAnalysis: z.string().optional().describe("Error analysis (for investigate)"),
      canReproduce: z.boolean().optional().describe("Can reproduce (for investigate)"),
      reproductionNotes: z.string().optional().describe("Reproduction notes (for investigate)"),
      recentChanges: z.array(z.string()).optional().describe("Recent changes (for investigate)"),
      component: z.string().optional().describe("Component (for evidence)"),
      input: z.string().optional().describe("Input (for evidence)"),
      output: z.string().optional().describe("Output (for evidence)"),
      expected: z.string().optional().describe("Expected (for evidence)"),
      notes: z.string().optional().describe("Notes (for evidence)"),
      workingExamples: z.array(z.string()).optional().describe("Working examples (for patterns)"),
      referenceImplementations: z.array(z.string()).optional().describe("Reference implementations (for patterns)"),
      differences: z.array(z.string()).optional().describe("Differences (for patterns)"),
      dependencies: z.array(z.string()).optional().describe("Dependencies (for patterns)"),
      statement: z.string().optional().describe("Statement (for hypothesis)"),
      reasoning: z.string().optional().describe("Reasoning (for hypothesis)"),
      testPlan: z.string().optional().describe("Test plan (for hypothesis)"),
      hypothesisId: z.string().optional().describe("Hypothesis ID (for test)"),
      result: z.enum(["confirmed", "refuted", "inconclusive"]).optional().describe("Result (for test)"),
      testNotes: z.string().optional().describe("Test notes (for test)"),
      testCase: z.string().optional().describe("Test case (for fix)"),
      fixDescription: z.string().optional().describe("Fix description (for fix)"),
      testPassed: z.boolean().optional().describe("Test passed (for verify)"),
      noRegressions: z.boolean().optional().describe("No regressions (for verify)"),
      status: z.string().optional().describe("Status filter (for list)"),
      thought: z.string().optional().describe("Thought to check (for redflags)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startDebugSession({
          agentId: input.agentId,
          title: input.title,
          description: input.description,
          errorMessage: input.errorMessage,
          stackTrace: input.stackTrace,
          reproductionSteps: input.reproductionSteps,
          repoPath: input.repoPath,
        }));
      case "investigate":
        return wrapResult(await logInvestigation({
          sessionId: input.sessionId,
          errorAnalysis: input.errorAnalysis,
          canReproduce: input.canReproduce,
          reproductionNotes: input.reproductionNotes,
          recentChanges: input.recentChanges,
          repoPath: input.repoPath,
        }));
      case "evidence":
        return wrapResult(await addEvidence({
          sessionId: input.sessionId,
          component: input.component,
          input: input.input,
          output: input.output,
          expected: input.expected,
          notes: input.notes,
          repoPath: input.repoPath,
        }));
      case "phase1":
        return wrapResult(await completePhase1({
          sessionId: input.sessionId,
          repoPath: input.repoPath,
        }));
      case "patterns":
        return wrapResult(await logPatterns({
          sessionId: input.sessionId,
          workingExamples: input.workingExamples,
          referenceImplementations: input.referenceImplementations,
          differences: input.differences,
          dependencies: input.dependencies,
          repoPath: input.repoPath,
        }));
      case "phase2":
        return wrapResult(await completePhase2({
          sessionId: input.sessionId,
          repoPath: input.repoPath,
        }));
      case "hypothesis":
        return wrapResult(await formHypothesis({
          sessionId: input.sessionId,
          statement: input.statement,
          reasoning: input.reasoning,
          testPlan: input.testPlan,
          repoPath: input.repoPath,
        }));
      case "test":
        return wrapResult(await testHypothesis({
          sessionId: input.sessionId,
          hypothesisId: input.hypothesisId,
          result: input.result,
          testNotes: input.testNotes,
          repoPath: input.repoPath,
        }));
      case "fix":
        return wrapResult(await implementFix({
          sessionId: input.sessionId,
          testCase: input.testCase,
          fixDescription: input.fixDescription,
          repoPath: input.repoPath,
        }));
      case "verify":
        return wrapResult(await verifyFix({
          sessionId: input.sessionId,
          testPassed: input.testPassed,
          noRegressions: input.noRegressions,
          notes: input.notes,
          repoPath: input.repoPath,
        }));
      case "get":
        return wrapResult(await getDebugSession({
          sessionId: input.sessionId,
          repoPath: input.repoPath,
        }));
      case "list":
        return wrapResult(await listDebugSessions({
          status: input.status,
          repoPath: input.repoPath,
        }));
      case "redflags":
        return wrapResult(await checkRedFlags({
          thought: input.thought,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 25. swarm_spec - Specification pipeline
 */
export const swarmSpecTool = [
  "swarm_spec",
  {
    title: "Swarm Spec",
    description: "Specification pipeline. Actions: start, phase, complete, get, list, export",
    inputSchema: z.object({
      action: z.enum(["start", "phase", "complete", "get", "list", "export"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      title: z.string().optional().describe("Title (for start)"),
      description: z.string().optional().describe("Description (for start)"),
      maxIterations: z.number().optional().describe("Max iterations (for start)"),
      pipelineId: z.string().optional().describe("Pipeline ID"),
      role: z.string().optional().describe("Role (for phase, complete)"),
      output: z.string().optional().describe("Output (for complete)"),
      status: z.string().optional().describe("Status filter (for list)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startSpecPipeline({
          repoPath: input.repoPath,
          title: input.title,
          description: input.description,
          maxIterations: input.maxIterations,
          commitMode: input.commitMode || "push",
        }));
      case "phase":
        return wrapResult(await startSpecPhase({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
          role: input.role,
          commitMode: input.commitMode || "push",
        }));
      case "complete":
        return wrapResult(await completeSpecPhase({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
          role: input.role,
          output: input.output,
          commitMode: input.commitMode || "push",
        }));
      case "get":
        return wrapResult(await getSpecPipeline({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
        }));
      case "list":
        return wrapResult(await listSpecPipelines({
          repoPath: input.repoPath,
          status: input.status,
        }));
      case "export":
        return wrapResult(await exportSpecAsMarkdown({
          repoPath: input.repoPath,
          pipelineId: input.pipelineId,
          commitMode: input.commitMode || "push",
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 26. swarm_qa - QA loop management
 */
export const swarmQaTool = [
  "swarm_qa",
  {
    title: "Swarm QA",
    description: "QA loop management. Actions: start, iterate, fix, get, list, suggest, report",
    inputSchema: z.object({
      action: z.enum(["start", "iterate", "fix", "get", "list", "suggest", "report"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for start)"),
      branch: z.string().optional().describe("Branch (for start)"),
      maxIterations: z.number().optional().describe("Max iterations (for start)"),
      autoFix: z.boolean().optional().describe("Auto fix (for start)"),
      checks: z.array(z.string()).optional().describe("Checks (for start)"),
      loopId: z.string().optional().describe("Loop ID"),
      checkResults: z.any().optional().describe("Check results (for iterate)"),
      fixDescription: z.string().optional().describe("Fix description (for fix)"),
      status: z.string().optional().describe("Status filter (for list)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startQALoop({
          repoPath: input.repoPath,
          taskId: input.taskId,
          branch: input.branch,
          maxIterations: input.maxIterations,
          autoFix: input.autoFix,
          checks: input.checks,
          commitMode: input.commitMode || "push",
        }));
      case "iterate":
        return wrapResult(await runQAIteration({
          repoPath: input.repoPath,
          loopId: input.loopId,
          checkResults: input.checkResults,
          commitMode: input.commitMode || "push",
        }));
      case "fix":
        return wrapResult(await logQAFix({
          repoPath: input.repoPath,
          loopId: input.loopId,
          fixDescription: input.fixDescription,
          commitMode: input.commitMode || "push",
        }));
      case "get":
        return wrapResult(await getQALoop({
          repoPath: input.repoPath,
          loopId: input.loopId,
        }));
      case "list":
        return wrapResult(await listQALoops({
          repoPath: input.repoPath,
          status: input.status,
        }));
      case "suggest":
        return wrapResult(await getQAFixSuggestions({
          repoPath: input.repoPath,
          loopId: input.loopId,
        }));
      case "report":
        return wrapResult(await generateQAReport({
          repoPath: input.repoPath,
          loopId: input.loopId,
          commitMode: input.commitMode || "push",
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 27. swarm_hooks - Git guard hooks
 */
export const swarmHooksTool = [
  "swarm_hooks",
  {
    title: "Swarm Hooks",
    description: "Git guard hooks. Actions: install, uninstall, run, config, update, list",
    inputSchema: z.object({
      action: z.enum(["install", "uninstall", "run", "config", "update", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      preCommitChecks: z.array(z.string()).optional().describe("Pre-commit checks (for install)"),
      prePushChecks: z.array(z.string()).optional().describe("Pre-push checks (for install)"),
      bypassKeyword: z.string().optional().describe("Bypass keyword (for install)"),
      hooks: z.array(z.string()).optional().describe("Hooks to uninstall (for uninstall)"),
      hook: z.string().optional().describe("Hook name (for run, update)"),
      enabled: z.boolean().optional().describe("Enabled (for update)"),
      checks: z.array(z.string()).optional().describe("Checks (for update)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "install":
        return wrapResult(await installGuardHooks({
          repoPath: input.repoPath,
          preCommitChecks: input.preCommitChecks,
          prePushChecks: input.prePushChecks,
          bypassKeyword: input.bypassKeyword,
          commitMode: input.commitMode || "push",
        }));
      case "uninstall":
        return wrapResult(await uninstallGuardHooks({
          repoPath: input.repoPath,
          hooks: input.hooks,
        }));
      case "run":
        return wrapResult(await runGuardHooks({
          repoPath: input.repoPath,
          hook: input.hook,
        }));
      case "config":
        return wrapResult(await getGuardConfig({
          repoPath: input.repoPath,
        }));
      case "update":
        return wrapResult(await updateGuardHook({
          repoPath: input.repoPath,
          hook: input.hook,
          enabled: input.enabled,
          checks: input.checks,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listGuardHooks({
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ============ SMART TOOLS 28-41 ============

/**
 * 28. swarm_screenshot - Screenshot sharing
 */
export const swarmScreenshotTool = [
  "swarm_screenshot",
  {
    title: "Swarm Screenshot",
    description: "Screenshot sharing. Actions: share, list",
    inputSchema: z.object({
      action: z.enum(["share", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for share)"),
      imageBase64: z.string().optional().describe("Image base64 (for share)"),
      description: z.string().optional().describe("Description (for share)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "share":
        return wrapResult(await shareScreenshot({
          repoPath: input.repoPath,
          agent: input.agent,
          imageBase64: input.imageBase64,
          description: input.description,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listScreenshots(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 29. swarm_dependency - Dependency synchronization
 */
export const swarmDependencyTool = [
  "swarm_dependency",
  {
    title: "Swarm Dependency",
    description: "Dependency synchronization. Actions: signal, sync",
    inputSchema: z.object({
      action: z.enum(["signal", "sync"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      type: z.enum(["npm", "pip", "cargo", "go"]).optional().describe("Dependency type (for signal)"),
      added: z.array(z.string()).optional().describe("Added packages (for signal)"),
      removed: z.array(z.string()).optional().describe("Removed packages (for signal)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "signal":
        return wrapResult(await signalDependencyChange({
          repoPath: input.repoPath,
          type: input.type,
          added: input.added || [],
          removed: input.removed,
          commitMode: input.commitMode || "push",
        }));
      case "sync":
        return wrapResult(await syncDependencies(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 30. swarm_platform - Cross-platform checks
 */
export const swarmPlatformTool = [
  "swarm_platform",
  {
    title: "Swarm Platform",
    description: "Cross-platform checks. Actions: request, respond, list",
    inputSchema: z.object({
      action: z.enum(["request", "respond", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      fromAgent: z.string().optional().describe("From agent (for request)"),
      targetPlatforms: z.array(z.string()).optional().describe("Target platforms (for request)"),
      component: z.string().optional().describe("Component (for request)"),
      description: z.string().optional().describe("Description (for request)"),
      screenshotBase64: z.string().optional().describe("Screenshot base64 (for request, respond)"),
      checkId: z.string().optional().describe("Check ID (for respond)"),
      agent: z.string().optional().describe("Agent (for respond)"),
      result: z.enum(["pass", "fail"]).optional().describe("Result (for respond)"),
      issueDescription: z.string().optional().describe("Issue description (for respond)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "request":
        return wrapResult(await requestPlatformCheck({
          repoPath: input.repoPath,
          fromAgent: input.fromAgent,
          targetPlatforms: input.targetPlatforms,
          component: input.component,
          description: input.description,
          screenshotBase64: input.screenshotBase64,
          commitMode: input.commitMode || "push",
        }));
      case "respond":
        return wrapResult(await respondToPlatformCheck({
          repoPath: input.repoPath,
          checkId: input.checkId,
          agent: input.agent,
          result: input.result,
          issueDescription: input.issueDescription,
          screenshotBase64: input.screenshotBase64,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await getPendingPlatformChecks(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 31. swarm_immune - Immune system and CI alerts
 */
export const swarmImmuneTool = [
  "swarm_immune",
  {
    title: "Swarm Immune",
    description: "Immune system and CI alerts. Actions: alert, resolve, status, test, patrol",
    inputSchema: z.object({
      action: z.enum(["alert", "resolve", "status", "test", "patrol"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      level: z.enum(["info", "warning", "error", "critical"]).optional().describe("Alert level (for alert)"),
      source: z.string().optional().describe("Alert source (for alert)"),
      message: z.string().optional().describe("Alert message (for alert)"),
      details: z.any().optional().describe("Alert details (for alert)"),
      alertId: z.string().optional().describe("Alert ID (for resolve)"),
      runLint: z.boolean().optional().describe("Run lint (for patrol)"),
      checkImports: z.boolean().optional().describe("Check imports (for patrol)"),
      checkOptimizations: z.boolean().optional().describe("Check optimizations (for patrol)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "alert":
        return wrapResult(await reportCiAlert({
          repoPath: input.repoPath,
          level: input.level,
          source: input.source,
          message: input.message,
          details: input.details,
          commitMode: input.commitMode || "push",
        }));
      case "resolve":
        return wrapResult(await resolveAlert({
          repoPath: input.repoPath,
          alertId: input.alertId,
          commitMode: input.commitMode || "push",
        }));
      case "status":
        return wrapResult(await getImmuneStatus(input.repoPath));
      case "test":
        return wrapResult(await runLocalTests(input.repoPath));
      case "patrol":
        return wrapResult(await patrolMode({
          repoPath: input.repoPath,
          runLint: input.runLint,
          checkImports: input.checkImports,
          checkOptimizations: input.checkOptimizations,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 32. swarm_context - Context compression
 */
export const swarmContextTool = [
  "swarm_context",
  {
    title: "Swarm Context",
    description: "Context compression. Actions: estimate, compress, compress_many, stats",
    inputSchema: z.object({
      action: z.enum(["estimate", "compress", "compress_many", "stats"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      text: z.string().optional().describe("Text (for estimate)"),
      model: z.string().optional().describe("Model (for estimate)"),
      briefing: z.any().optional().describe("Briefing (for compress)"),
      maxTokens: z.number().optional().describe("Max tokens (for compress, compress_many)"),
      preserveCode: z.boolean().optional().describe("Preserve code (for compress)"),
      briefings: z.array(z.any()).optional().describe("Briefings (for compress_many)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "estimate":
        return wrapResult(await estimateContextSize({
          text: input.text,
          model: input.model,
        }));
      case "compress":
        return wrapResult(await compressBriefing({
          repoPath: input.repoPath,
          briefing: input.briefing,
          maxTokens: input.maxTokens,
          preserveCode: input.preserveCode,
        }));
      case "compress_many":
        return wrapResult(await compressMultipleBriefings({
          repoPath: input.repoPath,
          briefings: input.briefings || [],
          maxTokens: input.maxTokens,
        }));
      case "stats":
        return wrapResult(await getCompressionStats({
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 33. swarm_regression - Regression detection
 */
export const swarmRegressionTool = [
  "swarm_regression",
  {
    title: "Swarm Regression",
    description: "Regression detection. Actions: baseline, check, list, resolve, baselines",
    inputSchema: z.object({
      action: z.enum(["baseline", "check", "list", "resolve", "baselines"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      name: z.string().optional().describe("Baseline name (for baseline, check)"),
      agent: z.string().optional().describe("Agent name"),
      metrics: z.any().optional().describe("Metrics (for baseline)"),
      baselineName: z.string().optional().describe("Baseline name (for check)"),
      includeResolved: z.boolean().optional().describe("Include resolved (for list)"),
      regressionId: z.string().optional().describe("Regression ID (for resolve)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "baseline":
        return wrapResult(await saveBaseline({
          repoPath: input.repoPath,
          name: input.name,
          agent: input.agent,
          metrics: input.metrics,
          commitMode: input.commitMode || "push",
        }));
      case "check":
        return wrapResult(await checkRegression({
          repoPath: input.repoPath,
          baselineName: input.baselineName || input.name,
          agent: input.agent,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listRegressions({
          repoPath: input.repoPath,
          includeResolved: input.includeResolved,
        }));
      case "resolve":
        return wrapResult(await resolveRegression({
          repoPath: input.repoPath,
          regressionId: input.regressionId,
          agent: input.agent,
          commitMode: input.commitMode || "push",
        }));
      case "baselines":
        return wrapResult(await listBaselines({
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 34. swarm_expertise - Agent expertise tracking
 */
export const swarmExpertiseTool = [
  "swarm_expertise",
  {
    title: "Swarm Expertise",
    description: "Agent expertise tracking. Actions: track, suggest, record, experts, list",
    inputSchema: z.object({
      action: z.enum(["track", "suggest", "record", "experts", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      filesEdited: z.array(z.string()).optional().describe("Files edited (for track, record)"),
      files: z.array(z.string()).optional().describe("Files (for record, suggest)"),
      taskDescription: z.string().optional().describe("Task description (for suggest)"),
      filesLikelyInvolved: z.array(z.string()).optional().describe("Files likely involved (for suggest)"),
      directories: z.array(z.string()).optional().describe("Directories (for suggest)"),
      keywords: z.array(z.string()).optional().describe("Keywords (for suggest, record)"),
      taskKeywords: z.array(z.string()).optional().describe("Task keywords (for record)"),
      area: z.string().optional().describe("Area (for experts)"),
      limit: z.number().optional().describe("Limit (for experts)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "track":
        return wrapResult(await trackExpertise({
          repoPath: input.repoPath,
          agent: input.agent,
          filesEdited: input.filesEdited || [],
          commitMode: input.commitMode || "push",
        }));
      case "suggest":
        return wrapResult(await suggestAgentAdvanced({
          repoPath: input.repoPath,
          files: input.files,
          directories: input.directories,
          keywords: input.keywords,
        }));
      case "record":
        return wrapResult(await recordAgentEdit({
          repoPath: input.repoPath,
          agent: input.agent,
          files: input.files || input.filesEdited || [],
          taskKeywords: input.taskKeywords || input.keywords,
          commitMode: input.commitMode || "push",
        }));
      case "experts":
        return wrapResult(await getTopExperts({
          repoPath: input.repoPath,
          area: input.area,
          limit: input.limit,
        }));
      case "list":
        return wrapResult(await listAllAgentExpertise(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 35. swarm_conflict - Conflict prediction
 */
export const swarmConflictTool = [
  "swarm_conflict",
  {
    title: "Swarm Conflict",
    description: "Conflict prediction. Actions: predict, analyze, hotspots, record",
    inputSchema: z.object({
      action: z.enum(["predict", "analyze", "hotspots", "record"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      filesToEdit: z.array(z.string()).optional().describe("Files to edit (for predict)"),
      file: z.string().optional().describe("File (for record)"),
      agent: z.string().optional().describe("Agent (for record)"),
      resolved: z.boolean().optional().describe("Resolved (for record)"),
      lookbackDays: z.number().optional().describe("Lookback days (for analyze)"),
      limit: z.number().optional().describe("Limit (for hotspots)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "predict":
        return wrapResult(await predictConflicts({
          repoPath: input.repoPath,
          filesToEdit: input.filesToEdit || [],
        }));
      case "analyze":
        return wrapResult(await analyzeConflictHistory({
          repoPath: input.repoPath,
          lookbackDays: input.lookbackDays,
          commitMode: input.commitMode || "push",
        }));
      case "hotspots":
        return wrapResult(await getConflictHotspots({
          repoPath: input.repoPath,
          limit: input.limit,
        }));
      case "record":
        return wrapResult(await recordConflictEvent({
          repoPath: input.repoPath,
          file: input.file,
          agent: input.agent,
          resolved: input.resolved ?? false,
          commitMode: input.commitMode || "push",
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 36. swarm_timeline - Event timeline
 */
export const swarmTimelineTool = [
  "swarm_timeline",
  {
    title: "Swarm Timeline",
    description: "Event timeline. Actions: generate, visualize",
    inputSchema: z.object({
      action: z.enum(["generate", "visualize"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      since: z.string().optional().describe("Since timestamp (for generate)"),
      limit: z.number().optional().describe("Limit (for generate)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "generate":
        return wrapResult(await generateTimeline({
          repoPath: input.repoPath,
          since: input.since,
          limit: input.limit,
        }));
      case "visualize":
        return wrapResult(await getTimelineVisualization(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 37. swarm_docs - Auto documentation
 */
export const swarmDocsTool = [
  "swarm_docs",
  {
    title: "Swarm Docs",
    description: "Auto documentation. Actions: generate, task_docs, list, get",
    inputSchema: z.object({
      action: z.enum(["generate", "task_docs", "list", "get"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name (for generate, task_docs)"),
      taskId: z.string().optional().describe("Task ID (for generate, task_docs, get)"),
      feature: z.string().optional().describe("Feature name (for generate)"),
      description: z.string().optional().describe("Description (for generate)"),
      usage: z.string().optional().describe("Usage (for generate)"),
      taskTitle: z.string().optional().describe("Task title (for task_docs)"),
      filesModified: z.array(z.string()).optional().describe("Files modified (for task_docs)"),
      summary: z.string().optional().describe("Summary (for task_docs)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "generate":
        return wrapResult(await autoGenerateDocs({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          feature: input.feature,
          description: input.description,
          usage: input.usage,
          commitMode: input.commitMode || "push",
        }));
      case "task_docs":
        return wrapResult(await generateTaskDocumentation({
          repoPath: input.repoPath,
          taskId: input.taskId,
          taskTitle: input.taskTitle,
          agent: input.agent,
          filesModified: input.filesModified || [],
          summary: input.summary,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listDocumentation(input.repoPath));
      case "get":
        return wrapResult(await getDocumentation({
          repoPath: input.repoPath,
          taskId: input.taskId,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 38. swarm_advice - Collective advice
 */
export const swarmAdviceTool = [
  "swarm_advice",
  {
    title: "Swarm Advice",
    description: "Collective advice. Actions: request, provide, list",
    inputSchema: z.object({
      action: z.enum(["request", "provide", "list"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      taskId: z.string().optional().describe("Task ID (for request)"),
      problem: z.string().optional().describe("Problem (for request)"),
      context: z.string().optional().describe("Context (for request)"),
      codeSnippet: z.string().optional().describe("Code snippet (for request)"),
      filesInvolved: z.array(z.string()).optional().describe("Files involved (for request)"),
      attemptedSolutions: z.array(z.string()).optional().describe("Attempted solutions (for request)"),
      requestId: z.string().optional().describe("Request ID (for provide)"),
      suggestion: z.string().optional().describe("Suggestion (for provide)"),
      confidence: z.enum(["low", "medium", "high"]).optional().describe("Confidence (for provide)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "request":
        return wrapResult(await requestCollectiveAdvice({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
          problem: input.problem,
          context: input.context,
          codeSnippet: input.codeSnippet,
          filesInvolved: input.filesInvolved || [],
          attemptedSolutions: input.attemptedSolutions || [],
          commitMode: input.commitMode || "push",
        }));
      case "provide":
        return wrapResult(await provideAdvice({
          repoPath: input.repoPath,
          requestId: input.requestId,
          agent: input.agent,
          suggestion: input.suggestion,
          confidence: input.confidence,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await getOpenAdviceRequests(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 39. swarm_preemption - Urgent task preemption
 */
export const swarmPreemptionTool = [
  "swarm_preemption",
  {
    title: "Swarm Preemption",
    description: "Urgent task preemption. Actions: trigger, resolve, active",
    inputSchema: z.object({
      action: z.enum(["trigger", "resolve", "active"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for trigger)"),
      title: z.string().optional().describe("Title (for trigger)"),
      reason: z.string().optional().describe("Reason (for trigger)"),
      initiator: z.string().optional().describe("Initiator (for trigger)"),
      affectedFiles: z.array(z.string()).optional().describe("Affected files (for trigger)"),
      urgentId: z.string().optional().describe("Urgent ID (for resolve)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "trigger":
        return wrapResult(await triggerUrgentPreemption({
          repoPath: input.repoPath,
          taskId: input.taskId,
          title: input.title,
          reason: input.reason,
          initiator: input.initiator,
          affectedFiles: input.affectedFiles || [],
          commitMode: input.commitMode || "push",
        }));
      case "resolve":
        return wrapResult(await resolveUrgent({
          repoPath: input.repoPath,
          urgentId: input.urgentId,
          commitMode: input.commitMode || "push",
        }));
      case "active":
        return wrapResult(await getActiveUrgent(input.repoPath));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 40. swarm_clusters - Tool clusters
 */
export const swarmClustersTool = [
  "swarm_clusters",
  {
    title: "Swarm Clusters",
    description: "Tool clusters. Actions: init, list, tools, find, add, create, summary",
    inputSchema: z.object({
      action: z.enum(["init", "list", "tools", "find", "add", "create", "summary"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      clusterId: z.string().optional().describe("Cluster ID (for tools, add)"),
      toolName: z.string().optional().describe("Tool name (for find, add)"),
      id: z.string().optional().describe("ID (for create)"),
      name: z.string().optional().describe("Name (for create)"),
      description: z.string().optional().describe("Description (for create)"),
      icon: z.string().optional().describe("Icon (for create)"),
      tools: z.array(z.string()).optional().describe("Tools (for create)"),
      commitMode: z.enum(["none", "local", "push"]).optional().default("push"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "init":
        return wrapResult(await initToolClusters({
          repoPath: input.repoPath,
          commitMode: input.commitMode || "push",
        }));
      case "list":
        return wrapResult(await listToolClusters({
          repoPath: input.repoPath,
        }));
      case "tools":
        return wrapResult(await getClusterTools({
          repoPath: input.repoPath,
          clusterId: input.clusterId,
        }));
      case "find":
        return wrapResult(await findToolCluster({
          repoPath: input.repoPath,
          toolName: input.toolName,
        }));
      case "add":
        return wrapResult(await addToolToCluster({
          repoPath: input.repoPath,
          clusterId: input.clusterId,
          toolName: input.toolName,
          commitMode: input.commitMode || "push",
        }));
      case "create":
        return wrapResult(await createToolCluster({
          repoPath: input.repoPath,
          id: input.id,
          name: input.name,
          description: input.description,
          icon: input.icon,
          tools: input.tools,
          commitMode: input.commitMode || "push",
        }));
      case "summary":
        return wrapResult(await getToolClusterSummary({
          repoPath: input.repoPath,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 41. swarm_session - Session recording
 */
export const swarmSessionTool = [
  "swarm_session",
  {
    title: "Swarm Session",
    description: "Session recording. Actions: start, log, stop, list, replay",
    inputSchema: z.object({
      action: z.enum(["start", "log", "stop", "list", "replay"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agent: z.string().optional().describe("Agent name"),
      taskId: z.string().optional().describe("Task ID (for start)"),
      sessionId: z.string().optional().describe("Session ID"),
      actionType: z.string().optional().describe("Action type (for log)"),
      tool: z.string().optional().describe("Tool (for log)"),
      file: z.string().optional().describe("File (for log)"),
      inputData: z.any().optional().describe("Input data (for log)"),
      outputData: z.any().optional().describe("Output data (for log)"),
      duration: z.number().optional().describe("Duration ms (for log)"),
      error: z.string().optional().describe("Error (for log)"),
      summary: z.string().optional().describe("Summary (for stop)"),
      limit: z.number().optional().describe("Limit (for list)"),
      fromIndex: z.number().optional().describe("From index (for replay)"),
      toIndex: z.number().optional().describe("To index (for replay)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "start":
        return wrapResult(await startSessionRecording({
          repoPath: input.repoPath,
          agent: input.agent,
          taskId: input.taskId,
        }));
      case "log":
        return wrapResult(await logSessionAction({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          actionType: input.actionType,
          tool: input.tool,
          file: input.file,
          inputData: input.inputData,
          outputData: input.outputData,
          duration: input.duration,
          error: input.error,
        }));
      case "stop":
        return wrapResult(await stopSessionRecording({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          summary: input.summary,
        }));
      case "list":
        return wrapResult(await listSessionRecordings({
          repoPath: input.repoPath,
          agent: input.agent,
          limit: input.limit,
        }));
      case "replay":
        return wrapResult(await replaySession({
          repoPath: input.repoPath,
          sessionId: input.sessionId,
          fromIndex: input.fromIndex,
          toIndex: input.toIndex,
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

// ============ NEW SMART TOOLS 42-46 (v0.9.3) ============

/**
 * 42. swarm_routing - Smart task routing based on file expertise
 */
export const swarmRoutingTool = [
  "swarm_routing",
  {
    title: "Swarm Routing",
    description: "Smart task routing based on file expertise. Actions: record, find_agent, expertise, predict, auto_assign",
    inputSchema: z.object({
      action: z.enum(["record", "find_agent", "expertise", "predict", "auto_assign"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      agentId: z.string().optional().describe("Agent ID"),
      filePath: z.string().optional().describe("File path (for record)"),
      filePaths: z.array(z.string()).optional().describe("File paths (for find_agent)"),
      excludeBusy: z.boolean().optional().describe("Exclude busy agents (for find_agent)"),
      taskDescription: z.string().optional().describe("Task description (for predict, auto_assign)"),
      taskId: z.string().optional().describe("Task ID (for auto_assign)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "record":
        return wrapResult(await recordFileEdit({
          repoPath: input.repoPath,
          agentName: input.agentId,
          filePath: input.filePath,
        }));
      case "find_agent":
        return wrapResult(await findBestAgent({
          repoPath: input.repoPath,
          affectedPaths: input.filePaths || [],
          excludeAgents: input.excludeBusy ? [] : undefined,
        }));
      case "expertise":
        return wrapResult(await getExpertiseMap({ repoPath: input.repoPath }));
      case "predict":
        return wrapResult(predictAffectedPaths(input.taskDescription || ""));
      case "auto_assign":
        return wrapResult(await autoAssignTask({
          repoPath: input.repoPath,
          taskId: input.taskId,
          taskTitle: input.taskDescription || "",
          taskDescription: input.taskDescription || "",
          availableAgents: [],
        }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 43. swarm_context_pool - Shared context notes between agents
 */
export const swarmContextPoolTool = [
  "swarm_context_pool",
  {
    title: "Swarm Context Pool",
    description: "Shared context notes between agents. Actions: add, get, search_tag, search, helpful, update, cleanup, stats",
    inputSchema: z.object({
      action: z.enum(["add", "get", "search_tag", "search", "helpful", "update", "cleanup", "stats"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      path: z.string().optional().describe("File/symbol path"),
      agentId: z.string().optional().describe("Agent ID"),
      summary: z.string().optional().describe("Note summary"),
      content: z.string().optional().describe("Note content"),
      tags: z.array(z.string()).optional().describe("Tags"),
      category: z.enum(["architecture", "api", "bug", "performance", "security", "documentation", "other"]).optional().describe("Category"),
      noteId: z.string().optional().describe("Note ID (for helpful, update)"),
      tag: z.string().optional().describe("Tag to search (for search_tag)"),
      query: z.string().optional().describe("Search query (for search)"),
      maxAgeDays: z.number().optional().describe("Max age in days (for cleanup)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "add":
        return wrapResult(await addContextNote({
          repoPath: input.repoPath,
          targetPath: input.path,
          content: input.content,
          summary: input.summary || input.content?.slice(0, 100) || "",
          tags: input.tags,
          category: input.category,
          author: input.agentId,
        }));
      case "get":
        return wrapResult(await getContextNotes({
          repoPath: input.repoPath,
          targetPath: input.path,
        }));
      case "search_tag":
        return wrapResult(await searchContextByTag({
          repoPath: input.repoPath,
          tag: input.tag,
        }));
      case "search":
        return wrapResult(await searchContext({
          repoPath: input.repoPath,
          query: input.query,
        }));
      case "helpful":
        return wrapResult(await markNoteHelpful({
          repoPath: input.repoPath,
          noteId: input.noteId,
        }));
      case "update":
        return wrapResult(await updateContextNote({
          repoPath: input.repoPath,
          noteId: input.noteId,
          content: input.content,
          tags: input.tags,
        }));
      case "cleanup":
        return wrapResult(await cleanupStaleNotes({
          repoPath: input.repoPath,
          olderThanDays: input.maxAgeDays,
        }));
      case "stats":
        return wrapResult(await getContextStats({ repoPath: input.repoPath }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 44. swarm_autoreview - Automatic code review assignment
 */
export const swarmAutoReviewTool = [
  "swarm_autoreview",
  {
    title: "Swarm Auto Review",
    description: "Automatic code review assignment. Actions: create, assign, comment, complete, resolve, for_reviewer, for_author, pending, stats",
    inputSchema: z.object({
      action: z.enum(["create", "assign", "comment", "complete", "resolve", "for_reviewer", "for_author", "pending", "stats"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      taskId: z.string().optional().describe("Task ID (for create)"),
      authorId: z.string().optional().describe("Author agent ID"),
      affectedFiles: z.array(z.string()).optional().describe("Affected files"),
      reviewId: z.string().optional().describe("Review ID"),
      reviewerId: z.string().optional().describe("Reviewer agent ID"),
      filePath: z.string().optional().describe("File path (for comment)"),
      line: z.number().optional().describe("Line number (for comment)"),
      commentText: z.string().optional().describe("Comment text"),
      severity: z.enum(["critical", "major", "minor", "suggestion"]).optional().describe("Comment severity"),
      approved: z.boolean().optional().describe("Approved (for complete)"),
      summary: z.string().optional().describe("Review summary"),
      commentId: z.string().optional().describe("Comment ID (for resolve)"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    switch (input.action) {
      case "create":
        return wrapResult(await createReviewRequest({
          repoPath: input.repoPath,
          taskId: input.taskId,
          taskTitle: input.taskId,
          codeAuthor: input.authorId,
          changedFiles: input.affectedFiles || [],
          changesSummary: input.summary || "",
        }));
      case "assign":
        return wrapResult(await assignReviewer({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          reviewer: input.reviewerId,
        }));
      case "comment":
        return wrapResult(await addReviewComment({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          author: input.reviewerId,
          filePath: input.filePath,
          lineNumber: input.line,
          content: input.commentText,
          severity: input.severity === "critical" ? "blocker" : input.severity === "major" ? "warning" : input.severity === "minor" ? "suggestion" : "info",
        }));
      case "complete":
        return wrapResult(await completeReview({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          reviewer: input.reviewerId,
          approved: input.approved ?? false,
          summary: input.summary || "",
        }));
      case "resolve":
        return wrapResult(await resolveComment({
          repoPath: input.repoPath,
          reviewId: input.reviewId,
          commentId: input.commentId,
        }));
      case "for_reviewer":
        return wrapResult(await getReviewsForReviewer({
          repoPath: input.repoPath,
          reviewer: input.reviewerId,
        }));
      case "for_author":
        return wrapResult(await getReviewsForAuthor({
          repoPath: input.repoPath,
          author: input.authorId,
        }));
      case "pending":
        return wrapResult(await getPendingReviews({ repoPath: input.repoPath }));
      case "stats":
        return wrapResult(await getReviewStats({ repoPath: input.repoPath }));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 45. swarm_external - GitHub/Linear sync
 */
export const swarmExternalTool = [
  "swarm_external",
  {
    title: "Swarm External",
    description: "GitHub and Linear.app sync. Actions: enable_github, enable_linear, sync_github, sync_linear, sync_all, export_github, export_linear, status, create_issue, close_issue, comment",
    inputSchema: z.object({
      action: z.enum(["enable_github", "enable_linear", "sync_github", "sync_linear", "sync_all", "export_github", "export_linear", "status", "create_issue", "close_issue", "comment"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // GitHub enable
      owner: z.string().optional().describe("GitHub owner"),
      repo: z.string().optional().describe("GitHub repo"),
      labelFilter: z.array(z.string()).optional().describe("Label filter"),
      autoImport: z.boolean().optional().describe("Auto import issues"),
      autoClose: z.boolean().optional().describe("Auto close on done"),
      // Linear enable
      teamId: z.string().optional().describe("Linear team ID"),
      projectId: z.string().optional().describe("Linear project ID"),
      // Export
      taskId: z.string().optional().describe("Task ID (for export)"),
      // Issue operations
      issueNumber: z.string().optional().describe("Issue number"),
      title: z.string().optional().describe("Issue title"),
      body: z.string().optional().describe("Issue body"),
      labels: z.array(z.string()).optional().describe("Labels"),
      comment: z.string().optional().describe("Comment text"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    switch (input.action) {
      case "enable_github":
        return wrapResult(await enableGitHubSync(repoPath, input.owner, input.repo, {
          labelFilter: input.labelFilter,
          autoImport: input.autoImport,
          autoClose: input.autoClose,
        }));
      case "enable_linear":
        return wrapResult(await enableLinearSync(repoPath, input.teamId, {
          projectId: input.projectId,
          autoImport: input.autoImport,
          autoClose: input.autoClose,
        }));
      case "sync_github":
        return wrapResult(await syncFromGitHub(repoPath));
      case "sync_linear":
        return wrapResult(await syncFromLinear(repoPath));
      case "sync_all":
        return wrapResult(await syncAll(repoPath));
      case "export_github":
        return wrapResult(await exportTaskToGitHub(repoPath, input.taskId));
      case "export_linear":
        return wrapResult(await exportTaskToLinear(repoPath, input.taskId));
      case "status":
        return wrapResult(await getSyncStatus(repoPath));
      case "create_issue":
        return wrapResult(await createGitHubIssue(repoPath, input.title, input.body, input.labels));
      case "close_issue":
        return wrapResult(await closeGitHubIssue(repoPath, input.issueNumber, input.comment));
      case "comment":
        return wrapResult(await addGitHubComment(repoPath, input.issueNumber, input.comment));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 46. swarm_budget - Cost optimization and model routing
 */
export const swarmBudgetTool = [
  "swarm_budget",
  {
    title: "Swarm Budget",
    description: "Cost optimization and smart model routing. Actions: analyze, models, select, recommend, route, log_usage, usage, stats, config, set_config, check, remaining, report",
    inputSchema: z.object({
      action: z.enum(["analyze", "models", "select", "recommend", "route", "log_usage", "usage", "stats", "config", "set_config", "check", "remaining", "report"]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // Task analysis
      taskTitle: z.string().optional().describe("Task title"),
      taskDescription: z.string().optional().describe("Task description"),
      affectedFiles: z.array(z.string()).optional().describe("Affected files"),
      requiredCapabilities: z.array(z.string()).optional().describe("Required capabilities"),
      preferCheaper: z.boolean().optional().describe("Prefer cheaper model"),
      forceModel: z.string().optional().describe("Force specific model"),
      // Usage logging
      agentId: z.string().optional().describe("Agent ID"),
      taskId: z.string().optional().describe("Task ID"),
      model: z.string().optional().describe("Model ID"),
      tier: z.enum(["cheap", "standard", "premium"]).optional().describe("Model tier"),
      inputTokens: z.number().optional().describe("Input tokens"),
      outputTokens: z.number().optional().describe("Output tokens"),
      // Config
      dailyLimit: z.number().optional().describe("Daily limit USD"),
      weeklyLimit: z.number().optional().describe("Weekly limit USD"),
      monthlyLimit: z.number().optional().describe("Monthly limit USD"),
      // Stats/report
      period: z.enum(["day", "week", "month"]).optional().describe("Period for stats/report"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    switch (input.action) {
      case "analyze":
        return wrapResult(analyzeTaskComplexity(
          input.taskTitle || "",
          input.taskDescription || "",
          input.affectedFiles
        ));
      case "models":
        return wrapResult(await getAvailableModels(repoPath));
      case "select":
        const complexity = analyzeTaskComplexity(
          input.taskTitle || "",
          input.taskDescription || "",
          input.affectedFiles
        );
        return wrapResult(await selectModel(repoPath, complexity, input.requiredCapabilities));
      case "recommend":
        return wrapResult(await recommendModel(
          repoPath,
          input.taskTitle || "",
          input.taskDescription || "",
          input.affectedFiles,
          input.requiredCapabilities
        ));
      case "route":
        return wrapResult(await routeTask(repoPath, input.taskTitle || "", input.taskDescription || "", {
          affectedFiles: input.affectedFiles,
          requiredCapabilities: input.requiredCapabilities,
          preferCheaper: input.preferCheaper,
          forceModel: input.forceModel,
        }));
      case "log_usage":
        return wrapResult(await logUsage(repoPath, {
          agentId: input.agentId,
          taskId: input.taskId,
          model: input.model,
          tier: input.tier || "standard",
          inputTokens: input.inputTokens || 0,
          outputTokens: input.outputTokens || 0,
        }));
      case "usage":
        return wrapResult(await getUsage(repoPath, {
          agentId: input.agentId,
          taskId: input.taskId,
          model: input.model,
          tier: input.tier,
        }));
      case "stats":
        return wrapResult(await getUsageStats(repoPath, input.period || "day"));
      case "config":
        return wrapResult(await getBudgetConfig(repoPath));
      case "set_config":
        return wrapResult(await setBudgetConfig(repoPath, {
          dailyLimit: input.dailyLimit,
          weeklyLimit: input.weeklyLimit,
          monthlyLimit: input.monthlyLimit,
        }));
      case "check":
        return wrapResult(await checkBudget(repoPath));
      case "remaining":
        return wrapResult(await getRemainingBudget(repoPath));
      case "report":
        return wrapResult(await generateCostReport(repoPath, input.period || "week"));
      default:
        throw new Error(`Unknown action: ${input.action}`);
    }
  },
] as const;

/**
 * 47. swarm_telegram - Telegram Bot integration
 */
export const swarmTelegramTool = [
  "swarm_telegram",
  {
    title: "Swarm Telegram",
    description: "Telegram Bot integration for notifications and control. Actions: setup, config, enable, disable, send, notify_task_created, notify_task_completed, notify_task_failed, notify_agent_joined, notify_agent_died, start_polling, stop_polling, command",
    inputSchema: z.object({
      action: z.enum([
        "setup", "config", "enable", "disable", "send",
        "notify_task_created", "notify_task_completed", "notify_task_failed",
        "notify_agent_joined", "notify_agent_died",
        "start_polling", "stop_polling", "command"
      ]).describe("Action to perform"),
      repoPath: z.string().optional(),
      // Config
      botToken: z.string().optional().describe("Telegram Bot Token (from @BotFather)"),
      chatId: z.string().optional().describe("Chat ID for notifications"),
      enabled: z.boolean().optional().describe("Enable/disable bot"),
      // Notifications
      taskId: z.string().optional().describe("Task ID"),
      title: z.string().optional().describe("Task title"),
      priority: z.string().optional().describe("Task priority"),
      agent: z.string().optional().describe("Agent name"),
      message: z.string().optional().describe("Message text"),
      // Command
      command: z.string().optional().describe("Bot command (e.g., /status)"),
      args: z.array(z.string()).optional().describe("Command arguments"),
    }).strict(),
    outputSchema: z.any(),
  },
  async (input: any) => {
    const repoPath = input.repoPath || process.cwd();
    return wrapResult(await handleTelegramTool({ ...input, repoPath }));
  },
] as const;

// ============ EXPORT ALL 47 SMART TOOLS ============

export const allSmartTools = [
  // 1-14: Core
  swarmAgentTool,
  swarmTaskTool,
  swarmFileTool,
  swarmGitTool,
  swarmWorktreeTool,
  swarmCompanionTool,
  swarmControlTool,
  swarmChatTool,
  swarmReviewTool,
  swarmVotingTool,
  swarmAuctionTool,
  swarmMcpTool,
  swarmOrchestratorTool,
  swarmMessageTool,
  // 15-27: Advanced
  swarmBriefingTool,
  swarmPulseTool,
  swarmKnowledgeTool,
  swarmSnapshotTool,
  swarmHealthTool,
  swarmQualityTool,
  swarmCostTool,
  swarmBrainstormTool,
  swarmPlanTool,
  swarmDebugTool,
  swarmSpecTool,
  swarmQaTool,
  swarmHooksTool,
  // 28-41: Specialized
  swarmScreenshotTool,
  swarmDependencyTool,
  swarmPlatformTool,
  swarmImmuneTool,
  swarmContextTool,
  swarmRegressionTool,
  swarmExpertiseTool,
  swarmConflictTool,
  swarmTimelineTool,
  swarmDocsTool,
  swarmAdviceTool,
  swarmPreemptionTool,
  swarmClustersTool,
  swarmSessionTool,
  // 42-46: v0.9.3 Smart Features
  swarmRoutingTool,
  swarmContextPoolTool,
  swarmAutoReviewTool,
  swarmExternalTool,
  swarmBudgetTool,
  // 47: v0.9.4 Telegram
  swarmTelegramTool,
];
